<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fantasy Golf</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Roboto+Mono:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --golf-green-900:#052e16;
      --golf-emerald-900:#064e3b;
      --golf-teal-900:#134e4a;
      --paper:#ffffff;
    }
    body{
      margin:0;
      font-family:'Manrope',ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,Arial,sans-serif;
    }
    .golf-bg{
      background-color:var(--golf-emerald-900);
      background-image:
        radial-gradient(circle at 15% 10%, rgba(255,255,255,0.10), transparent 45%),
        radial-gradient(circle at 85% 0%, rgba(255,255,255,0.06), transparent 45%),
        radial-gradient(circle at 70% 90%, rgba(255,255,255,0.05), transparent 50%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.03) 0 18px, rgba(0,0,0,0.08) 18px 36px),
        linear-gradient(135deg, var(--golf-emerald-900) 0%, var(--golf-green-900) 55%, var(--golf-teal-900) 100%);
      background-attachment:fixed;
    }
    .golf-dimples{
      background-image: radial-gradient(circle at 9px 9px, rgba(255,255,255,0.10) 1px, transparent 2px);
      background-size: 18px 18px;
      opacity: .22;
      mix-blend-mode: overlay;
      pointer-events:none;
    }
    .glass{
      background: rgba(255,255,255,0.88);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.35);
    }
    .score-num{
      font-family:'Roboto Mono',ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;
      font-variant-numeric: tabular-nums;
    }
    .live-hero{
      position: relative;
      overflow: hidden;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.14);
      background:
        radial-gradient(circle at 18% 12%, rgba(255,255,255,0.18), transparent 42%),
        radial-gradient(circle at 78% 0%, rgba(45,212,191,0.20), transparent 45%),
        radial-gradient(circle at 70% 88%, rgba(16,185,129,0.18), transparent 48%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.05) 0 14px, rgba(0,0,0,0.10) 14px 28px),
        linear-gradient(135deg, #0b1220 0%, #052e16 55%, #082f49 100%);
    }
    .live-hero::before{
      content:'';
      position:absolute;
      inset:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0));
      opacity: .35;
      pointer-events:none;
    }
    .live-hero::after{
      content:'';
      position:absolute;
      inset:0;
      background-image: radial-gradient(circle at 9px 9px, rgba(255,255,255,0.10) 1px, transparent 2px);
      background-size: 18px 18px;
      opacity: .10;
      mix-blend-mode: overlay;
      pointer-events:none;
    }

  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const TEAMS = [
      {
        id: 1,
        name: 'Nolan Kouba 1',
        players: [
          'Scottie Scheffler',
          'Akshay Bhatia',
          'Min Woo Lee',
          'Emiliano Grillo',
          'Luke Clanton',
          'Séamus Power',
        ],
      },
      {
        id: 2,
        name: 'Nolan Kouba 2',
        players: [
          'Ludvig Aberg',
          'Akshay Bhatia',
          'Rasmus Hojgaard',
          'Aldrich Potgieter',
          'Tom Hoge',
          'Keith Mitchell',
        ],
      },
      {
        id: 3,
        name: 'Nolan Kouba 3',
        players: [
          'Rory McIlroy',
          'Collin Morikawa',
          'Tom Hoge',
          'Keith Mitchell',
          'Adam Hadwin',
          'Jackson Koivun',
        ],
      },
      {
        id: 4,
        name: 'Drew Finley-Haag 1',
        players: [
          'Scottie Scheffler',
          'Si Woo Kim',
          'Rasmus Hojgaard',
          'Sahith Theegala',
          'Lee Hodges',
          'David Ford',
        ],
      },
      {
        id: 5,
        name: 'Drew Finley-Haag 2',
        players: [
          'Ludvig Aberg',
          'Chris Gotterup',
          'J.T. Poston',
          'Denny McCarthy',
          'Aldrich Potgieter',
          'Patrick Rodgers',
        ],
      },
      {
        id: 6,
        name: 'Drew Finley-Haag 3',
        players: [
          'Scottie Scheffler',
          'Chris Gotterup',
          'Matt McCarty',
          'Erik van Rooyen',
          'Pierceson Coody',
          'Matthieu Pavon',
        ],
      },
      {
        id: 7,
        name: 'Drew Finley-Haag 4',
        players: [
          'Ludvig Aberg',
          'Si Woo Kim',
          'Rasmus Hojgaard',
          'Min Woo Lee',
          'Aldrich Potgieter',
          'Pierceson Coody',
        ],
      },
      {
        id: 8,
        name: 'Drew Finley-Haag 5',
        players: [
          'Maverick McNealy',
          'Corey Conners',
          'Nick Taylor',
          'Billy Horschel',
          'Pierceson Coody',
          'Keith Mitchell',
        ],
      },

      {
        id: 9,
        name: 'Jacob Aegerter 1',
        players: [
          'Collin Morikawa',
          'Akshay Bhatia',
          'Sungjae Im',
          'Michael Kim',
          'Luke Clanton',
          'Adam Schenk',
        ],
      },
      {
        id: 10,
        name: 'Jacob Aegerter 2',
        players: [
          'Scottie Scheffler',
          'Viktor Hovland',
          'Max Homa',
          'Luke Clanton',
          'Taylor Montgomery',
          'Max McGreevy',
        ],
      },
      {
        id: 11,
        name: 'Jacob Aegerter 3',
        players: [
          'Akshay Bhatia',
          'Maverick McNealy',
          'Hideki Matsuyama',
          'Tom Kim',
          'Eric Cole',
          'Jackson Koivun',
        ],
      },
      {
        id: 12,
        name: 'Jake Livesey 1',
        players: [
          'Patrick Cantlay',
          'Max Homa',
          'Austin Eckroat',
          'Keith Mitchell',
          'Matt Fitzpatrick',
          'Nick Taylor',
        ],
      },
      {
        id: 13,
        name: 'Jake Livesey 2',
        players: [
          'Scottie Scheffler',
          'Ludvig Aberg',
          'Austin Eckroat',
          'Keith Mitchell',
          'Adrien Dumont de Chassart',
          'Beau Hossler',
        ],
      },


    ];

    const SCORING = {
      regular: {
        1: 125,
        2: 95,
        3: 90,
        4: 85,
        5: 80,
        6: 75,
        7: 70,
        8: 65,
        9: 60,
        10: 55,
        11: 54,
        12: 53,
        13: 52,
        14: 51,
        15: 50,
        16: 49,
        17: 48,
        18: 47,
        19: 46,
        20: 45,
        21: 44,
        22: 43,
        23: 42,
        24: 41,
        25: 40,
        26: 39,
        27: 38,
        28: 37,
        29: 36,
        30: 35,
        31: 34,
        32: 33,
        33: 32,
        34: 31,
        35: 30,
        36: 29,
        37: 28,
        38: 27,
        39: 26,
        40: 25,
        41: 24,
        42: 23,
        43: 22,
        44: 21,
        45: 20,
        46: 19,
        47: 18,
        48: 17,
        49: 16,
        50: 15,
        51: 14,
        52: 13,
        53: 12,
        54: 11,
        55: 10,
        56: 9,
        57: 8,
        58: 7,
        59: 6,
        60: 5,
      },
      major: {
        1: 175,
        2: 140,
        3: 135,
        4: 130,
        5: 125,
        6: 120,
        7: 115,
        8: 110,
        9: 105,
        10: 100,
        11: 95,
        12: 90,
        13: 85,
        14: 80,
        15: 75,
        16: 74,
        17: 73,
        18: 72,
        19: 71,
        20: 70,
        21: 69,
        22: 68,
        23: 67,
        24: 66,
        25: 65,
        26: 64,
        27: 63,
        28: 62,
        29: 61,
        30: 60,
        31: 59,
        32: 58,
        33: 57,
        34: 56,
        35: 55,
        36: 54,
        37: 53,
        38: 52,
        39: 51,
        40: 50,
        41: 48,
        42: 46,
        43: 44,
        44: 42,
        45: 40,
        46: 38,
        47: 36,
        48: 34,
        49: 32,
        50: 30,
        51: 28,
        52: 26,
        53: 24,
        54: 22,
        55: 20,
        56: 18,
        57: 16,
        58: 14,
        59: 12,
        60: 10,
      },
    };

    // Bonus points awarded to a TEAM based on how many of its golfers make the cut.
    // League rules (per screenshot): 3 => 20, 4 => 50, 5+ => 100
    const TEAM_CUT_BONUS = { 3: 20, 4: 50, 5: 100 };

    // Projected cut line used BEFORE the cut is officially made.
    // PGA Tour is typically Top 65 and ties. If your league uses a different number, change this.
    const PROJECTED_CUT_RANK = 64;

    // Analytics: build an 'optimal' 6-player lineup under a $120 salary cap.
    const OPTIMAL_LINEUP_SALARY_CAP = 120;
    const OPTIMAL_LINEUP_SIZE = 6;
    // Value smoothing strength (K). Higher = more conservative early-season.
    const BAYES_K = 2;

const DATA_VERSION = 4; // bumped: official fantasy schedule scope (Phoenix → BMW)


    const HISTORY_STORAGE_KEY = 'fgHistoryV3';
    const PRICES_STORAGE_KEY = 'fgPlayerPricesV1';
    const SCOREBOARD_URL =
      'https://site.api.espn.com/apis/site/v2/sports/golf/pga/scoreboard';

    // Tournament metadata (cut format, rounds, etc.)
    // We use this to correctly handle 36-hole cuts vs 54-hole cuts (cutRound=3), and no-cut events (cutRound=0).
    const LEADERBOARD_META_URL =
      'https://site.web.api.espn.com/apis/site/v2/sports/golf/leaderboard';

    const normalize = (s) => {
  const str = String(s || '').toLowerCase();

  // Normalize unicode and strip diacritics so names match ESPN even with accents/special characters.
  // Examples:
  //  - Séamus -> seamus
  //  - Åberg  -> aberg
  //  - Højgaard -> hojgaard
  let out = str;
  try {
    out = out.normalize('NFKD');
  } catch (e) {
    out = str;
  }

  // Remove combining diacritic marks
  out = out.replace(/[\u0300-\u036f]/g, '');

  // Map a few common special letters that may not decompose cleanly
  out = out
    .replace(/ß/g, 'ss')
    .replace(/[æ]/g, 'ae')
    .replace(/[œ]/g, 'oe')
    .replace(/[ø]/g, 'o')
    .replace(/[ð]/g, 'd')
    .replace(/[þ]/g, 'th')
    .replace(/[ł]/g, 'l')
    .replace(/[đ]/g, 'd')
    .replace(/[ı]/g, 'i');

  return out
    .replace(/[^a-z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
};

    const FIXED_PRICE_ROWS = [
      ['Scottie Scheffler', 45],
      ['Rory McIlroy', 38],
      ['Tommy Fleetwood', 36],
      ['Xander Schauffele', 34],
      ['Robert MacIntyre', 33],
      ['Ben Griffin', 32],
      ['Ludvig Aberg', 32],
      ['Brooks Koepka', 31],
      ['J.J. Spaun', 31],
      ['Collin Morikawa', 31],
      ['Russell Henley', 30],
      ['Sam Burns', 30],
      ['Sepp Straka', 29],
      ['Cameron Young', 29],
      ['Justin Thomas', 29],
      ['Patrick Cantlay', 29],
      ['Maverick McNealy', 28],
      ['Matt Fitzpatrick', 28],
      ['Keegan Bradley', 28],
      ['Justin Rose', 27],
      ['Harris English', 27],
      ['Hideki Matsuyama', 27],
      ['Viktor Hovland', 26],
      ['Corey Conners', 26],
      ['Brian Harman', 26],
      ['Shane Lowry', 25],
      ['Andrew Novak', 25],
      ['Akshay Bhatia', 24],
      ['Sungjae Im', 24],
      ['Chris Gotterup', 23],
      ['Si Woo Kim', 23],
      ['Wyndham Clark', 22],
      ['Aaron Rai', 22],
      ['Jacob Bridgeman', 21],
      ['Harry Hall', 21],
      ['Billy Horschel', 21],
      ['Tony Finau', 21],
      ['Michael Kim', 20],
      ['Nick Taylor', 20],
      ['Ryan Gerard', 20],
      ['Jordan Spieth', 19],
      ['Ryan Fox', 19],
      ['Rasmus Hojgaard', 19],
      ['Taylor Pendrith', 19],
      ['Alex Noren', 19],
      ['Kurt Kitayama', 19],
      ['Sam Stevens', 18],
      ['Jason Day', 18],
      ['Sami Valimaki', 18],
      ['Max Greyserman', 18],
      ['Min Woo Lee', 18],
      ['Denny McCarthy', 18],
      ['Daniel Berger', 18],
      ['Sahith Theegala', 18],
      ['J.T. Poston', 17],
      ['Lucas Glover', 17],
      ['Rickie Fowler', 17],
      ['Chris Kirk', 17],
      ['Nico Echavarria', 17],
      ['Tom Kim', 17],
      ['Max Homa', 17],
      ['Will Zalatoris', 17],
      ['Nicolai Hojgaard', 16],
      ['Matt McCarty', 16],
      ['Bud Cauley', 16],
      ['Jake Knapp', 16],
      ['Aldrich Potgieter', 16],
      ['Tom Hoge', 16],
      ['Jhonattan Vegas', 16],
      ['Christian Bezuidenhout', 16],
      ['Eric Cole', 16],
      ['Stephan Jaeger', 16],
      ['Michael Thorbjornsen', 15],
      ['Brian Campbell', 15],
      ['Adam Scott', 15],
      ['Mackenzie Hughes', 15],
      ['Davis Riley', 15],
      ['Davis Thompson', 15],
      ['Kevin Yu', 15],
      ['Byeong Hun An', 15],
      ['Marco Penge', 15],
      ['Emiliano Grillo', 14],
      ['Matthias Schmid', 14],
      ['Ryo Hisatsune', 14],
      ['Patrick Rodgers', 14],
      ['Max McGreevy', 14],
      ['Johnny Keefer', 14],
      ['Garrick Higgo', 13],
      ['Rico Hoey', 13],
      ['Mark Hubbard', 13],
      ['Joe Highsmith', 13],
      ['Gary Woodland', 13],
      ['Michael Brennan', 13],
      ['Erik van Rooyen', 13],
      ['Keith Mitchell', 13],
      ['Pierceson Coody', 12],
      ['Kristoffer Reitan', 12],
      ['Thorbjorn Olesen', 12],
      ['Alex Smalley', 12],
      ['Vince Whaley', 12],
      ['Rasmus Neergaard-Petersen', 12],
      ['Matt Wallace', 12],
      ['Cam Davis', 12],
      ['Austin Eckroat', 12],
      ['Adam Hadwin', 12],
      ['William Mouw', 11],
      ['Takumi Kanaya', 11],
      ['Mac Meissner', 11],
      ['Kevin Roy', 11],
      ['Haotong Li', 11],
      ['Nick Dunlap', 11],
      ['Taylor Moore', 11],
      ['Luke Clanton', 11],
      ['Matthieu Pavon', 11],
      ['Steven Fisk', 10],
      ['Karl Vilips', 10],
      ['Beau Hossler', 10],
      ['Adam Schenk', 10],
      ['Lee Hodges', 10],
      ['Patrick Fishburn', 10],
      ['Chandler Phillips', 10],
      ['Jordan Smith', 10],
      ['David Lipsky', 10],
      ['Matt Kuchar', 9],
      ['Chad Ramey', 9],
      ['Neal Shipley', 9],
      ['Daniel Brown', 9],
      ['Adrien Saddier', 9],
      ['Keita Nakajima', 9],
      ['Ricky Castillo', 9],
      ['John Parry', 9],
      ['Danny Walker', 8],
      ['Jesper Svensson', 8],
      ['Andrew Putnam', 8],
      ['Doug Ghim', 8],
      ['Chandler Blanchet', 8],
      ['Justin Lower', 8],
      ['Isaiah Salinda', 8],
      ['Séamus Power', 8],
      ['S.H. Kim', 8],
      ['Adrien Dumont de Chassart', 8],
      ['Chris Lamprecht', 8],
      ['Austin Smotherman', 8],
      ['Jackson Suber', 8],
      ['Alejandro Tosti', 8],
      ['Carson Young', 8],
      ['Joel Dahmen', 8],
      ['Sam Ryder', 8],
      ['Kensei Hirata', 8],
      ['Landon Griffin', 8],
      ['Emilio Gonzalez', 8],
      ['Jackson Koivun', 8],
      ['Kiri Ventura', 7],
      ['Trace Crowe', 7],
      ['Taylor Montgomery', 7],
      ['Harry Higgs', 7],
      ['Zach Johnson', 7],
      ['Hayden Springer', 7],
      ['Charley Hoffman', 7],
      ['Patton Kizzire', 7],
      ['Hank Lebioda', 7],
      ['Henrik Norlander', 7],
      ['Chan Kim', 7],
      ['Ben Silverman', 7],
      ['Jeffrey Kang', 7],
      ['Frankie Capan III', 7],
      ['Zach Bauchou', 7],
      ['Paul Peterson', 7],
      ['Greyson Sigg', 7],
      ['Zecheng Dou', 7],
      ['Brandt Snedeker', 7],
      ['Adam Svensson', 7],
      ['David Skinns', 7],
      ['Davis Chatfield', 7],
      ['Ben Kohles', 7],
      ['S.T. Lee', 7],
      ['Brice Garnett', 7],
      ['Noah Goodwin', 7],
      ['Paul Waring', 7],
      ['Zac Blair', 7],
      ['Jeremy Paul', 7],
      ['Pontus Nyholm', 7],
      ['Sudarshan Yellamaraju', 7],
      ['Webb Simpson', 7],
      ['Gordon Sargent', 7],
      ['Tiger Ward', 7],
      ['Danny Willett', 5],
      ['John VanDerLaan', 5],
      ['Nate Lashley', 5],
      ['Cameron Champ', 5],
      ['Will Gordon', 5],
      ['Troy Mullinax', 5],
      ['Dylan Wu', 5],
      ['Rafael Campos', 5],
      ['C.T. Pan', 5],
      ['K.H. Lee', 5],
      ['Kevin Streelman', 5],
      ['Peter Malnati', 5],
      ['David Ford', 5],
      ['A.J. Ewart', 5],
      ['Marcello Rozo', 5],
      ['Brendan Todd', 5],
      ['Aaron Baddeley', 5],
      ['Vincent Norman', 5],
      ['Vince Covello', 5],
      ['Jimmy Stanger', 5],
      ['Parker Coody', 5],
      ['Aaron Wise', 5],
      ['Scott Stallings', 5],
      ['Michael Lindheim', 5],
      ['Michael Thompson', 5],
      ['Vijay Singh', 5]
    ];

    const FIXED_PRICES = FIXED_PRICE_ROWS.reduce((acc, [name, price]) => {
      const key = normalize(name);
      if (!key) return acc;
      acc[key] = Number(price);
      return acc;
    }, {});

    // Fallback cut-round inference (used if ESPN cutRound metadata is unavailable due to CORS).
    // Add tournaments here as needed.
    // - 3 => 54-hole cut (after Round 3)
    // - 2 => standard 36-hole cut (after Round 2)
    // - 0 => no cut
    const inferCutRoundFromEventName = (eventName) => {
      const n = normalize(eventName);
      if (!n) return null;

      // Multi-course Pro-Am style event: 54-hole cut (field cut after three rounds)
      if (n.includes('american express')) return 3;

      return null;
    };

    const isMajorName = (name) => {
      const s = String(name || '');
      return (
        /players/i.test(s) ||
        /masters/i.test(s) ||
        /pga\s+championship/i.test(s) ||
        /u\.?\s*s\.?\s*open/i.test(s) ||
        /british\s+open/i.test(s) ||
        /\bthe\s+open\b/i.test(s) ||
        /open\s+championship/i.test(s)
      );
    };

    // Extract the current round number from ESPN's competition status.
    // ESPN payloads vary by tournament, so we combine multiple fields.
    // Returns 1..4 when detected, otherwise null.
    const extractRoundFromCompetition = (comp) => {
      const st = comp?.status?.type || {};
      const periodCandidates = [
        comp?.status?.period,
        st?.period,
        comp?.status?.type?.period,
      ].filter((n) => typeof n === 'number' && n > 0 && n <= 4);
      if (periodCandidates.length) return periodCandidates[0];

      const texts = [
        st.detail,
        st.shortDetail,
        st.description,
        st.name,
        st.abbreviation,
        comp?.status?.detail,
        comp?.status?.shortDetail,
      ]
        .filter(Boolean)
        .join(' ');

      const m =
        texts.match(/round\s*([1-4])/i) ||
        texts.match(/\brd\.?\s*([1-4])\b/i) ||
        texts.match(/\bR\s*([1-4])\b/i) ||
        texts.match(/\bR([1-4])\b/i);
      if (m) return parseInt(m[1], 10);

      // Don't infer a round number from generic "post"/"completed" flags here.
      // A single round can be "post" (play complete) while the tournament is still in progress.
      return null;
    };
    // Determine whether the cut has been OFFICIALLY applied yet (live tournament).
    // ESPN will sometimes label golfers as "CUT" mid-round as a projection. We ignore that
    // until the cut round is actually complete.
    const computeCutApplied = ({ completed, round, cutRound, compStatusText, competitors }) => {
      const cutRoundNum =
        cutRound === 0
          ? 0
          : typeof cutRound === 'number'
          ? cutRound
          : cutRound != null
          ? Number(cutRound)
          : null;

      const effectiveCutRound =
        typeof cutRoundNum === 'number' && !Number.isNaN(cutRoundNum) ? cutRoundNum : 2;

      if (completed) return true;
      if (!effectiveCutRound || effectiveCutRound <= 0) return false; // no-cut

      if (typeof round === 'number') {
        if (round > effectiveCutRound) return true;   // past the cut round (weekend)
        if (round < effectiveCutRound) return false;  // definitely pre-cut
      }

      const comps = Array.isArray(competitors) ? competitors : [];

      const hasMC = comps.some((c) => {
        const ab = String(c?.status?.type?.abbreviation || '').toUpperCase();
        return ab === 'MC' || ab === 'MDF';
      });

      const hasAnyCutLabel = comps.some((c) => {
        const st = c?.status?.type || {};
        const ab = String(st.abbreviation || '').toUpperCase();
        const nm = String(st.name || '').toUpperCase();
        const dt = String(st.shortDetail || st.detail || st.description || '').toUpperCase();
        return ab === 'MC' || ab === 'MDF' || ab === 'CUT' || nm === 'CUT' || /\bMISSED\s+CUT\b/.test(dt);
      });

      // Strongest signal: MC/MDF appears.
      if (hasMC) return true;

      // If the cut round is marked "Play Complete" AND ESPN is labeling cut golfers,
      // treat the cut as official (even if we're still on the cut round number).
      const txt = String(compStatusText || '').toLowerCase();
      const playComplete = txt.includes('play complete');

      if (playComplete && hasAnyCutLabel) return true;

      return false;
    };


    const getLeaderboardUrlFromEvent = (eventObj, eventId) => {
      const id = String(eventId || eventObj?.id || '');
      const candidates = [];

      const links = eventObj?.links;
      if (Array.isArray(links)) {
        for (const l of links) {
          if (l?.href) candidates.push(String(l.href));
        }
      }
      if (eventObj?.link) candidates.push(String(eventObj.link));
      if (eventObj?.url) candidates.push(String(eventObj.url));

      // Prefer whatever ESPN provides in the API payload.
      const preferred = candidates.find((u) =>
        /espn\.com\/golf\/leaderboard/i.test(u)
      );
      if (preferred) return preferred;

      // Fallback to ESPN's current canonical format.
      if (id) {
        return `https://www.espn.com/golf/leaderboard?tournamentId=${encodeURIComponent(
          id
        )}`;
      }

      return '';
    };

    // ---------------------------------------------------------------------------
    // Fantasy Schedule (Phoenix Open → BMW Championship)
    // Scope is now aligned to the official JT Fantasy Golf season.
    //
    // Notes:
    // - Only tournaments listed here count for Previous / Season Long / Analytics.
    // - "Majors" (use MAJOR scoring table): THE PLAYERS, THE MASTERS, PGA Championship, U.S. Open, British Open (The Open Championship).
    // - Team cut bonus rules are the same for majors and regular events.
    // ---------------------------------------------------------------------------

    const FANTASY_SCHEDULE = [
      { key: 'phoenix', match: /phoenix\s+open/i, isMajor: false },
      { key: 'pebble', match: /pebble\s+beach/i, isMajor: false },
      { key: 'genesis', match: /genesis/i, isMajor: false },
      { key: 'cognizant', match: /cognizant/i, isMajor: false },
      { key: 'arnold_palmer', match: /arnold\s+palmer/i, isMajor: false },
      { key: 'players', match: /players/i, isMajor: true },
      { key: 'valspar', match: /valspar/i, isMajor: false },
      { key: 'houston', match: /houston/i, isMajor: false },
      { key: 'valero', match: /valero/i, isMajor: false },
      { key: 'masters', match: /masters/i, isMajor: true },
      { key: 'rbc_heritage', match: /rbc\s+heritage/i, isMajor: false },
      { key: 'zurich', match: /zurich/i, isMajor: false },
      { key: 'cadillac', match: /cadillac/i, isMajor: false },
      { key: 'truist', match: /truist|wells\s+fargo/i, isMajor: false },
      { key: 'pga_championship', match: /pga\s+championship/i, isMajor: true },
      { key: 'cj_cup', match: /\bcj\s+cup\b/i, isMajor: false },
      { key: 'charles_schwab', match: /charles\s+schwab/i, isMajor: false },
      { key: 'memorial', match: /\bmemorial\b/i, isMajor: false },
      { key: 'canadian_open', match: /canadian\s+open/i, isMajor: false },
      { key: 'us_open', match: /u\.?\s*s\.?\s*open/i, isMajor: true },
      { key: 'travelers', match: /travelers/i, isMajor: false },
      { key: 'john_deere', match: /john\s+deere/i, isMajor: false },
      { key: 'scottish_open', match: /scottish\s+open/i, isMajor: false },
      { key: 'open_championship', match: /\bthe\s+open\b|open\s+championship|british\s+open/i, isMajor: true },
      { key: '3m_open', match: /\b3m\b/i, isMajor: false },
      { key: 'rocket', match: /rocket\s+mortgage|rocket\s+classic|\brocket\b/i, isMajor: false },
      { key: 'wyndham', match: /wyndham/i, isMajor: false },
      { key: 'fedex_st_jude', match: /st\.?\s*jude/i, isMajor: false },
      { key: 'bmw', match: /bmw\s+championship/i, isMajor: false },
    ];

    const getScheduleEntry = (label) => {
      const s = String(label || '');
      return FANTASY_SCHEDULE.find((t) => t.match.test(s)) || null;
    };

    const safeDate = (v) => {
      const d = new Date(v || '');
      return isNaN(d.getTime()) ? null : d;
    };

    const getFantasySeasonBounds = (cal) => {
      if (!Array.isArray(cal) || cal.length === 0) return null;

      const start = cal.find((c) => getScheduleEntry(c.label)?.key === 'phoenix');
      const end = cal.find((c) => getScheduleEntry(c.label)?.key === 'bmw');
      if (!start || !end) return null;

      const startStart =
        safeDate(start.startDate) || safeDate(start.beginDate) || safeDate(start.endDate);
      const startEnd = safeDate(start.endDate) || safeDate(start.startDate);
      const endEnd = safeDate(end.endDate) || safeDate(end.startDate);

      if (!startStart || !startEnd || !endEnd) return null;

      return {
        start: {
          id: String(start.id || ''),
          label: start.label || 'WM Phoenix Open',
          startDate: startStart,
          endDate: startEnd,
        },
        end: {
          id: String(end.id || ''),
          label: end.label || 'BMW Championship',
          endDate: endEnd,
        },
      };
    };

    const getSeasonStarted = (bounds) => {
      if (!bounds || !bounds.start?.endDate) return false;
      const end = bounds.start.endDate;
      return end instanceof Date && !isNaN(end.getTime()) && new Date() > end;
    };

    const isInFantasySeasonWindow = (calItem, bounds) => {
      if (!bounds || !calItem) return false;

      // Only allow tournaments that match our official fantasy schedule list.
      if (!getScheduleEntry(calItem.label)) return false;

      const d = safeDate(calItem.endDate || calItem.date || calItem.startDate);
      if (!d) return false;

      // Also enforce Phoenix → BMW date window to avoid cross-season leakage.
      return d >= bounds.start.startDate && d <= bounds.end.endDate;
    };

    const isMajorByScheduleLabel = (label) => !!getScheduleEntry(label)?.isMajor;


    const isEventIdInFantasySeason = (eventId, cal, bounds) => {
      if (!eventId || !bounds) return false;
      const item = (cal || []).find((c) => String(c.id) === String(eventId));
      return item ? isInFantasySeasonWindow(item, bounds) : false;
    };


    const yyyymmddFromIso = (iso) =>
      String(iso || '')
        .slice(0, 10)
        .replace(/-/g, '');

    const loadHistoryFromStorage = () => {
      const raw =
        localStorage.getItem(HISTORY_STORAGE_KEY);
      if (!raw) return { seasonYear: null, tournaments: [] };
      try {
        const parsed = JSON.parse(raw);
        // v2/v3 (object payload)
        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
          const v = parsed.version ?? 0;
          // If the stored version doesn't match our current data version, ignore cached tournaments.
          // They will be re-synced from ESPN using the latest scoring/cut logic.
          if (v !== DATA_VERSION) {
            return { seasonYear: parsed.seasonYear ?? null, tournaments: [] };
          }
          return {
            seasonYear: parsed.seasonYear ?? null,
            tournaments: Array.isArray(parsed.tournaments) ? parsed.tournaments : [],
          };
        }
        // legacy
        if (Array.isArray(parsed)) {
          return { seasonYear: null, tournaments: parsed };
        }
      } catch (e) {
        console.error(e);
      }
      return { seasonYear: null, tournaments: [] };
    };

    const saveHistoryToStorage = (seasonYear, tournaments) => {
      try {
        localStorage.setItem(
          HISTORY_STORAGE_KEY,
          JSON.stringify({ version: DATA_VERSION, seasonYear, tournaments })
        );
      } catch (e) {
        console.error(e);
      }
    };

    const loadPricesFromStorage = () => {
      try {
        const raw = localStorage.getItem(PRICES_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (e) {
        console.error(e);
        return {};
      }
    };

    const savePricesToStorage = (pricesMap) => {
      try {
        localStorage.setItem(PRICES_STORAGE_KEY, JSON.stringify(pricesMap || {}));
      } catch (e) {
        console.error(e);
      }
    };

    const parsePricesText = (text) => {
      const out = {};
      const lines = String(text || '').split(/\r?\n/);
      let count = 0;

      for (const line of lines) {
        const trimmed = String(line || '').trim();
        if (!trimmed) continue;

        let name = '';
        let priceStr = '';

        // Accept: "Name<TAB>Price" or "Name,Price"
        const delimited = trimmed
          .split(/\t|,/)
          .map((x) => x.trim())
          .filter(Boolean);

        if (delimited.length >= 2) {
          name = delimited.slice(0, -1).join(' ');
          priceStr = delimited[delimited.length - 1];
        } else {
          // Fallback: assume last token is the numeric price
          const tokens = trimmed.split(/\s+/);
          const last = tokens[tokens.length - 1];
          if (/^\d+(?:\.\d+)?$/.test(last)) {
            name = tokens.slice(0, -1).join(' ');
            priceStr = last;
          } else {
            continue;
          }
        }

        const price = Number(priceStr);
        if (!name || !Number.isFinite(price) || price <= 0) continue;

        const key = normalize(name);
        if (!key) continue;

        out[key] = price;
        count++;
      }

      return { map: out, count };
    };

    function App() {
      const [tab, setTab] = useState('live');
      const [search, setSearch] = useState('');
      const [data, setData] = useState([]);
      const [loading, setLoading] = useState(false);
      const [info, setInfo] = useState({
        name: 'Loading...',
        isMajor: false,
        url: '',
        eventId: '',
        state: '',
        round: null,
        // ESPN tournament meta:
        // - cutRound=2 => standard 36-hole cut (after Round 2)
        // - cutRound=3 => 54-hole cut (after Round 3)
        // - cutRound=0 => no cut
        cutRound: null,
        numberOfRounds: null,
        cutApplied: false,
        completed: false,
      });
      const [update, setUpdate] = useState(null);
      const [auto, setAuto] = useState(true);
      const [history, setHistory] = useState([]);
const [selected, setSelected] = useState(null);
const [expanded, setExpanded] = useState({});

// Always use compact layout (optimized for large leagues)
const compact = true;
const c = (compactCls, normalCls) => compactCls;

const syncInFlightRef = useRef(false);
const cutMetaRef = useRef({}); // { [eventId]: { cutRound, numberOfRounds } }
      const [calendar, setCalendar] = useState([]);
      const [seasonYear, setSeasonYear] = useState(null);
      const [fantasySeason, setFantasySeason] = useState({ bounds: null, started: false });

      const [statsSubtab, setStatsSubtab] = useState('points');
      const [prices, setPrices] = useState(FIXED_PRICES);
      const [priceImportOpen, setPriceImportOpen] = useState(false);
      const [priceText, setPriceText] = useState('');


      useEffect(() => {

        // Don't hydrate Previous/Season until we know the fantasy-season window (Phoenix → BMW).
        // syncHistoryFromCalendar() will load + filter correctly once ESPN calendar is available.
        setHistory([]);
        fetchData();
      }, []);

      useEffect(() => {
        if (!auto) return;
        const int = setInterval(fetchData, 60000);
        return () => clearInterval(int);
      }, [auto]);

      const toggle = (key) =>
        setExpanded((prev) => ({ ...prev, [key]: !prev[key] }));

      const findPlayer = (name, players) => {
  const search = normalize(name);
  if (!search) return null;

  const list = players || [];

  // 1) Exact normalized match
  let hit = list.find((p) => normalize(p.name) === search);
  if (hit) return hit;

  // 2) Fuzzy contains match (handles minor ESPN formatting differences)
  hit = list.find((p) => {
    const pname = normalize(p.name);
    return pname.includes(search) || search.includes(pname);
  });
  if (hit) return hit;

  // 3) Last-name fallback (handles middle initials / suffixes / punctuation)
  const sTokens = search.split(' ').filter(Boolean);
  const sLast = sTokens[sTokens.length - 1] || '';
  const sFirst = sTokens[0] || '';

  if (!sLast) return null;

  hit = list.find((p) => {
    const pname = normalize(p.name);
    const t = pname.split(' ').filter(Boolean);
    const last = t[t.length - 1] || '';
    if (last !== sLast) return false;

    // If we can, enforce first-initial match as a light disambiguator
    const first = t[0] || '';
    if (sFirst && first) return first[0] === sFirst[0];
    return true;
  });

  return hit || null;
};

      const getScore = (name, players = data, isMajor = info.isMajor) => {
  const p = findPlayer(name, players);
  if (!p) return 0;

  const liveContext = players === data;

  // If the LIVE tournament hasn't started yet, don't award points.
  // (This avoids giving points when ESPN is in "pre" state and no leaderboard exists yet.)
  if (liveContext && info?.state === 'pre') return 0;

  // If the tournament has begun but THIS golfer has not started yet,
  // ESPN may still list them as T1 at E. They should not earn points until they tee off.
  if (liveContext && p.started === false) return 0;

  // No points for withdrawals / DQ / DNS / DNF.
  if (p.withdrawn) return 0;

  // If we don't have a position/score, they can't score.
  if (p.pos === 'N/A' || p.score === '-' || p.score == null) return 0;

  const num =
    typeof p.posNum === 'number' && p.posNum > 0
      ? p.posNum
      : parseInt(String(p.pos || '').replace(/[^0-9]/g, ''), 10);
  if (!num) return 0;

  // ---------------------------------------------------------------------
  // Cut logic (league request):
  // - During Round 1 / Round 2: hard cutoff at Top PROJECTED_CUT_RANK.
  //   Anyone with position > PROJECTED_CUT_RANK gets 0, regardless of ESPN tags.
  // - During Round 3 / Round 4 (or completed): use ESPN's missed-cut labels.
  //
  // We apply this guard *here* as a safety net so points can never leak to
  // golfers outside the cut line during R1/R2 even if ESPN metadata is noisy.
  // ---------------------------------------------------------------------

  const liveRound = liveContext ? info?.round : null;

  // Cut-round handling:
  // ESPN provides `cutRound` via tournament metadata:
  //  - 2 => standard 36-hole cut (after Round 2)
  //  - 3 => 54-hole cut (after Round 3)
  //  - 0 => no cut
  const cutRoundRaw = liveContext ? info?.cutRound : null;
  const cutRoundNum =
    cutRoundRaw === 0
      ? 0
      : typeof cutRoundRaw === 'number'
      ? cutRoundRaw
      : cutRoundRaw != null
      ? Number(cutRoundRaw)
      : 2;

  const effectiveCutRound =
    typeof cutRoundNum === 'number' && !Number.isNaN(cutRoundNum)
      ? cutRoundNum
      : 2;

  const hasCut = liveContext && effectiveCutRound > 0;
  const completedLive = liveContext ? !!info?.completed : false;
  const cutAppliedLive = liveContext ? !!info?.cutApplied : false;

  // Projection mode is used BEFORE the cut is officially applied.
  const isProjectionMode = liveContext && hasCut && !completedLive && !cutAppliedLive;

  // Safety-net: while the cut is NOT official, enforce the projected cut line.
  if (isProjectionMode && num > PROJECTED_CUT_RANK) return 0;

  let makingCut = false;

  if (liveContext) {
    if (!hasCut) {
      // No-cut events: everyone (who hasn't withdrawn) is effectively "making the cut".
      makingCut = true;
    } else {
      makingCut = isProjectionMode
        ? num <= PROJECTED_CUT_RANK
        : typeof p.makingCut === 'boolean'
        ? p.makingCut
        : typeof p.cut === 'boolean'
        ? p.cut
        : false;
    }
  } else {
    // Historical tournaments: trust the saved per-player makingCut flag.
    makingCut =
      typeof p.makingCut === 'boolean'
        ? p.makingCut
        : typeof p.cut === 'boolean'
        ? p.cut
        : false;
  }
  if (!makingCut) return 0;

  const table = isMajor ? SCORING.major : SCORING.regular;

  // League rule (per screenshot):
  // - Places 1..60 score per the table
  // - 60th+ AND making the cut => 60th-place points (5 regular / 10 major)
  if (num <= 60) return table[num] || 0;
  return table[60] || 0;
};

      const getTeamCutBonusForCount = (madeCutCount) => {
        if (!madeCutCount || madeCutCount < 3) return 0;
        if (madeCutCount >= 5) return TEAM_CUT_BONUS[5] || 0;
        return TEAM_CUT_BONUS[madeCutCount] || 0;
      };

      const getMadeCutCountForTeam = (team, players = data) => {
        const liveContext = players === data;

        // Before a tournament starts, nobody can be "making the cut" yet.
        if (liveContext && info?.state === 'pre') return 0;

        const cutRoundRaw = liveContext ? info?.cutRound : null;
        const cutRoundNum =
          cutRoundRaw === 0
            ? 0
            : typeof cutRoundRaw === 'number'
            ? cutRoundRaw
            : cutRoundRaw != null
            ? Number(cutRoundRaw)
            : 2;

        const effectiveCutRound =
          typeof cutRoundNum === 'number' && !Number.isNaN(cutRoundNum)
            ? cutRoundNum
            : 2;

        const hasCut = liveContext && effectiveCutRound > 0;
        const completedLive = liveContext ? !!info?.completed : false;
        const cutAppliedLive = liveContext ? !!info?.cutApplied : false;

        // Projection mode is used BEFORE the cut is officially applied.
        const isProjectionMode = liveContext && hasCut && !completedLive && !cutAppliedLive;

        return (team.players || []).reduce((n, name) => {
          const p = findPlayer(name, players);
          if (!p) return n;
          if (p.withdrawn) return n;

          // If the golfer hasn't teed off yet, don't count them toward cut bonus.
          if (liveContext && p.started === false) return n;

          if (isProjectionMode) {
            const posNum =
              typeof p.posNum === 'number'
                ? p.posNum
                : parseInt(String(p.pos || '').replace(/[^0-9]/g, ''), 10);
            return n + (posNum && posNum <= PROJECTED_CUT_RANK ? 1 : 0);
          }

          return n + (p.makingCut ? 1 : 0);
        }, 0);
      };

      const getTeamTotalScore = (team, players = data, isMajor = info.isMajor) => {
        const base = (team.players || []).reduce(
          (s, name) => s + getScore(name, players, isMajor),
          0
        );
        const made = getMadeCutCountForTeam(team, players);
        return base + getTeamCutBonusForCount(made);
      };


      const buildPlayersFromCompetitors = (comps, completed, eventRound, eventCutRound, cutApplied) => {
  // Count how many rounds we have a real score for.
  // ESPN payloads vary: sometimes linescores have `displayValue`, sometimes only `value`.
  // Treat a round as "reported" if either field is present and not a dash.
  const isRoundReported = (x) => {
    if (!x) return false;

    const isPlaceholder = (val) => {
      const s = String(val ?? '').trim();
      if (!s) return true;
      const up = s.toUpperCase();
      if (up === '-' || up === '—' || up === '--' || up === '---') return true;
      if (up === 'N/A' || up === 'NA') return true;
      // ESPN sometimes uses "0" as a placeholder for unplayed rounds.
      if (/^0(\.0+)?$/.test(s)) return true;
      return false;
    };

    // If ESPN gives us a displayValue, trust it first.
    const dvRaw = x.displayValue;
    if (dvRaw != null) {
      return !isPlaceholder(dvRaw);
    }

    const v = x.value;
    if (v == null) return false;

    // If displayValue is missing, be conservative:
    // ESPN sometimes uses 0 as a placeholder for unplayed rounds.
    if (typeof v === 'number') {
      if (Number.isNaN(v)) return false;
      if (v === 0) return false;
      return true;
    }

    return !isPlaceholder(v);
  };

  const roundsReportedFor = (competitor) => {
    const ls = competitor?.linescores || [];
    return ls.filter(isRoundReported).length;
  };

  // Treat the cut as "official" once the weekend begins (any golfer has 3+ rounds),
  // or if the event is completed.
  // Before that, we use a *projected* cut line by position so we can show "who's making the cut"
  // without trusting ESPN's sometimes-early "CUT" labels.
  const maxRounds = Math.max(
    0,
    ...(comps || []).map((c) => roundsReportedFor(c))
  );

  // R1/R2: projected cut by position (Top PROJECTED_CUT_RANK)
  // R3/R4 (or completed): use ESPN's missed-cut labeling.
  const roundNum =
    typeof eventRound === 'number' && eventRound > 0 ? eventRound : null;

  // ESPN tournament meta includes `cutRound`:
  //  - cutRound=2 => standard 36-hole cut (after Round 2)
  //  - cutRound=3 => 54-hole cut (after Round 3)
  //  - cutRound=0 => no cut
  const cutRoundNum =
    eventCutRound === 0
      ? 0
      : typeof eventCutRound === 'number'
      ? eventCutRound
      : eventCutRound != null
      ? Number(eventCutRound)
      : null;

  const effectiveCutRound =
    typeof cutRoundNum === 'number' && !Number.isNaN(cutRoundNum)
      ? cutRoundNum
      : 2;

  const hasCut = effectiveCutRound > 0;

  // Projection mode is used BEFORE the cut is officially applied.
  // Once cutApplied=true, we trust ESPN's missed-cut labels (MC/MDF/CUT) for scoring.
  const useProjection = hasCut && !completed && !cutApplied;

  let lastScore = null;
  let lastPosNum = null;

  return (comps || []).map((c, i) => {
    const score = c.score ?? 'E';

    // ESPN sorts the leaderboard by score, so ties can be detected by equal scores.
    // IMPORTANT: we must display tie positions as T{rank} (e.g. both tied for 2nd show T2),
    // not as the row index (which would incorrectly show the 2nd tied golfer as T3, etc).
    const nextScore = (comps || [])[i + 1]?.score ?? null;

    const tieWithPrev = lastScore !== null && score === lastScore;
    const tieWithNext = nextScore !== null && score === nextScore;
    const inTieGroup = tieWithPrev || tieWithNext;

    // posNum is tie-aware (T1/T1 then next is 3, etc). We use posNum for scoring.
    const posNum = tieWithPrev ? lastPosNum : i + 1;
    if (!tieWithPrev) lastPosNum = posNum;
    lastScore = score;

    // Detect statuses that should earn 0 points (WD / DQ / DNS / DNF).
    // ESPN status fields vary by event/state, so we build a robust combined string.
    const st = c.status?.type || {};
    const statusAbbr = String(st.abbreviation || '').toUpperCase();
    const statusName = String(st.name || '').toUpperCase();
    const statusState = String(st.state || '').toUpperCase();
    const statusDetail = String(
      st.shortDetail || st.detail || st.description || ''
    ).toUpperCase();
    const statusText = `${statusAbbr} ${statusName} ${statusState} ${statusDetail}`.trim();

    const roundsReported = roundsReportedFor(c);

    // Determine whether THIS golfer has actually started.
    // Prefer ESPN's per-golfer status state when available ("pre" before tee-off).
    // Fall back to whether we have any reported round score.
    const playerState = String(st.state || '').toLowerCase();
    const started = completed
      ? true
      : playerState
      ? playerState !== 'pre'
      : roundsReported > 0;

    const scoreCode = String(score || '').toUpperCase();
    const withdrawn =
      ['WD', 'DQ', 'DNS', 'DNF'].includes(statusAbbr) ||
      ['WD', 'DQ', 'DNS', 'DNF'].includes(scoreCode) ||
      statusText.includes('WITHDRAW') ||
      statusText.includes('DISQUAL') ||
      statusText.includes('DID NOT START') ||
      statusText.includes('DID NOT FINISH');

    // IMPORTANT:
    // We do NOT show "CUT" in the position column before the cut is official.
    // Scoring logic (requested):
    // - R1/R2: projected cut by position (Top PROJECTED_CUT_RANK and ties)
    // - R3/R4 (or completed): trust ESPN's missed-cut labeling (MC / MDF / CUT)
    // ESPN golf scoreboard payloads sometimes omit `status` on golfers who miss the cut
    // (notably at some 54-hole cut events like The American Express). When that happens, we
    // infer missed-cut by comparing rounds played to the cut round once the cut is official.
    const explicitMissedCut =
      ['MC', 'MDF', 'CUT'].includes(statusAbbr) ||
      statusName === 'CUT' ||
      /\bMISSED\s+CUT\b/.test(statusText);

    let inferredMissedCut = false;
    const roundNum = typeof eventRound === 'number' ? eventRound : Number(eventRound);

    if (!withdrawn && effectiveCutRound !== 0) {
      if (completed) {
        // Tournament complete: anyone who didn't record scores beyond the cut round did not advance.
        inferredMissedCut = roundsReported <= effectiveCutRound;
      } else if (!useProjection && Number.isFinite(roundNum) && roundNum > effectiveCutRound) {
        // Tournament has moved past the cut round (weekend/final round):
        // If a golfer has no scores beyond the cut round AND isn't active for the current round,
        // they have missed the cut even if ESPN omits explicit MC/CUT labels.
        const isActive = playerState === 'pre' || playerState === 'in';
        if (!isActive && roundsReported <= effectiveCutRound) inferredMissedCut = true;
      }
    }

    const missedCut = explicitMissedCut || inferredMissedCut;

    const makingCut =
      !withdrawn &&
      (effectiveCutRound === 0
        ? true
        : useProjection
        ? posNum <= PROJECTED_CUT_RANK
        : !missedCut);

    // Always display the golfer's place (tie-aware). We don't show "CUT" mid-tournament.
    let posDisplay = inTieGroup ? `T${posNum}` : `${posNum}`;

    // If the cut is official (weekend), show CUT for missed-cut golfers.
    if (!useProjection && missedCut && !withdrawn && effectiveCutRound !== 0) posDisplay = 'CUT';

    // For withdrawals, show the status (WD/DQ/etc) in the position column.
    if (withdrawn) posDisplay = statusAbbr || 'WD';

    return {
      name: c.athlete?.displayName || 'Unknown',
      statusAbbr,
      officialMc: ['MC','MDF'].includes(statusAbbr),
      pos: posDisplay,
      posNum,
      score: score || 'E',
      makingCut,
      withdrawn,
      started: completed ? true : started,
      thru: completed
        ? 'F'
        : roundsReported >= 3
        ? 'F'
        : `R${c.linescores?.length || 1}`,
      roundsReported,
    };
  });
};

const scorePlayerObject = (pl, isMajor) => {
        if (!pl) return 0;
        if (pl.withdrawn) return 0;

        const num =
          typeof pl.posNum === 'number' && pl.posNum > 0
            ? pl.posNum
            : parseInt(String(pl.pos || '').replace(/[^0-9]/g, ''), 10);

        if (!num) return 0;
        if (!pl.makingCut) return 0;

        const table = isMajor ? SCORING.major : SCORING.regular;
        if (num <= 60) return table[num] || 0;
        return table[60] || 0;
      };

      const computeFieldForTournament = (players, isMajor) =>
        (players || []).map((pl) => ({
          name: pl.name,
          points: scorePlayerObject(pl, isMajor),
          pos: pl.pos,
          score: pl.score,
          madeCut: !!pl.makingCut,
        }));

const computeTeamsForTournament = (players, isMajor) =>
        TEAMS.map((team) => {
          const lineup = (team.players || []).map((p) => {
            const player = findPlayer(p, players);
            if (!player) return { name: p, points: 0, pos: 'N/A', score: '-', madeCut: false };
            const pts = getScore(p, players, isMajor);
            return { name: p, points: pts, pos: player.pos, score: player.score, madeCut: !!player.makingCut };
          });

          const madeCutCount = lineup.reduce((n, pl) => n + (pl.madeCut ? 1 : 0), 0);
          const cutBonus = getTeamCutBonusForCount(madeCutCount);
          const baseScore = lineup.reduce((s, pl) => s + pl.points, 0);

          return {
            id: team.id,
            name: team.name,
            score: baseScore + cutBonus,
            players: lineup,
            madeCutCount,
            cutBonus,
          };
        });

      const mergeAndSortHistory = (tournaments) => {
        // Deduplicate by eventId (preferred), else by name+date.
        const byKey = new Map();
        for (const t of tournaments) {
          const key = String(t.eventId || t.id || `${t.name}-${t.date}`);
          byKey.set(key, { ...t, id: t.eventId || t.id || t.id });
        }
        const merged = Array.from(byKey.values());
        merged.sort((a, b) => new Date(a.date) - new Date(b.date));
        return merged;
      };

      const attachEventIdsToLegacy = (tournaments, cal) => {
        const calList = Array.isArray(cal) ? cal : [];
        return (tournaments || []).map((t) => {
          if (t.eventId) return t;
          const tName = normalize(t.name);
          const tDate = t.date ? new Date(t.date) : null;

          const match = calList.find((c) => {
            const cName = normalize(c.label);
            if (!tName || !cName) return false;
            const nameMatch = cName.includes(tName) || tName.includes(cName);
            if (!nameMatch) return false;
            if (!tDate) return true;
            const end = new Date(c.endDate);
            const diffDays = Math.abs(end.getTime() - tDate.getTime()) / 86400000;
            return diffDays <= 7;
          });

          if (!match) return t;
          const eventId = String(match.id);
          return {
            ...t,
            id: eventId,
            eventId,
            name: t.name || match.label,
            url: t.url || getLeaderboardUrlFromEvent(null, eventId),
          };
        });
      };

      const fetchTournamentByDate = async (yyyymmdd, expectedEventId, fallbackLabel) => {
        const url = `${SCOREBOARD_URL}?dates=${yyyymmdd}`;
        const res = await fetch(url);
        const json = await res.json();
        const e =
          json?.events?.find((ev) => String(ev.id) === String(expectedEventId)) ||
          json?.events?.[0];

        if (!e) return null;

        const comp = e.competitions?.[0];

        // Use EVENT status to determine tournament completion (competition status can be "Round X - Play Complete").
        const eventStatus = e?.status?.type || {};
        const completed = eventStatus?.completed === true || eventStatus?.state === 'post';
        if (!completed) return null;

        const name = e.name || fallbackLabel || 'PGA Tournament';
        const isMajor = isMajorName(name);
        const eventId = String(e.id);
        const espnUrl = getLeaderboardUrlFromEvent(e, eventId);

        // Determine cutRound for this completed event (needed for 54-hole cut events like The American Express)
        let cutRound = null;
        let numberOfRounds = null;

        const cachedMeta = cutMetaRef.current[eventId];
        if (cachedMeta) {
          cutRound = cachedMeta.cutRound;
          numberOfRounds = cachedMeta.numberOfRounds;
        } else {
          try {
            const metaRes = await fetch(
              `${LEADERBOARD_META_URL}?tournamentId=${encodeURIComponent(eventId)}`
            );
            const metaJson = await metaRes.json();
            const metaEvent =
              (metaJson?.events || []).find(
                (ev) => String(ev.id) === String(eventId)
              ) || metaJson?.events?.[0];

            const tmeta = metaEvent?.tournament || {};
            if (tmeta.cutRound !== undefined && tmeta.cutRound !== null)
              cutRound = Number(tmeta.cutRound);
            if (tmeta.numberOfRounds !== undefined && tmeta.numberOfRounds !== null)
              numberOfRounds = Number(tmeta.numberOfRounds);

            cutMetaRef.current[eventId] = { cutRound, numberOfRounds };
          } catch (err) {
            console.error(err);
          }
        }

        const inferredCutRound = inferCutRoundFromEventName(name);
        if (
          (cutRound === null ||
            cutRound === undefined ||
            Number.isNaN(Number(cutRound))) &&
          inferredCutRound != null
        ) {
          cutRound = inferredCutRound;
        }

        // Cache resolved meta so we don't repeatedly hit (or fail) the meta endpoint.
        cutMetaRef.current[eventId] = { cutRound, numberOfRounds };

        const cutRoundNum =
          cutRound === 0
            ? 0
            : cutRound != null && !Number.isNaN(Number(cutRound))
            ? Number(cutRound)
            : 2;

        const comps = comp?.competitors || [];
        const players = buildPlayersFromCompetitors(comps, true, null, cutRoundNum, true);
        const teams = computeTeamsForTournament(players, isMajor);
        const field = computeFieldForTournament(players, isMajor);

        return {
          id: eventId,
          eventId,
          name,
          date: e.endDate || comp?.endDate || new Date().toISOString(),
          isMajor,
          url: espnUrl,
          field,
          teams,
        };
      };

      const syncHistoryFromCalendar = async (
        cal,
        yr,
        currentEventId,
        bounds,
        seasonStarted
      ) => {
        if (!Array.isArray(cal) || cal.length === 0) return;

        // If we can't determine the window (Phoenix → BMW), stay empty rather than show wrong data.
        if (!bounds || !seasonStarted) {
          setHistory([]);
          return;
        }

        if (syncInFlightRef.current) return;
        syncInFlightRef.current = true;

        try {
          const stored = loadHistoryFromStorage();
          let tournaments = Array.isArray(stored.tournaments) ? stored.tournaments : [];

          // If season year changed, drop cached tournaments (avoid mixing seasons).
          if (yr && stored.seasonYear && Number(stored.seasonYear) !== Number(yr)) {
            tournaments = [];
          }

          // Keep only tournaments within our fantasy season window.
          tournaments = tournaments.filter((t) =>
            isEventIdInFantasySeason(String(t.eventId || t.id || ''), cal, bounds)
          );

          // Remove any mistakenly-saved current tournament from history.
          if (currentEventId) {
            const curId = String(currentEventId);
            tournaments = tournaments.filter(
              (t) => String(t.eventId || t.id || '') !== curId
            );

            // Legacy safety: if someone saved current by name, remove by normalized name match.
            if (info?.name) {
              const n = normalize(info.name);
              tournaments = tournaments.filter((t) => normalize(t.name) !== n);
            }
          }

          tournaments = attachEventIdsToLegacy(tournaments, cal);

          const haveIds = new Set(
            tournaments
              .map((t) => String(t.eventId || t.id || ''))
              .filter(Boolean)
          );

          const now = new Date();
          const completedEvents = cal
            .filter((c) => new Date(c.endDate) < now)
            .filter((c) => isInFantasySeasonWindow(c, bounds))
            .sort((a, b) => new Date(a.endDate) - new Date(b.endDate));

          const missing = completedEvents.filter((c) => !haveIds.has(String(c.id)));

          if (missing.length === 0) {
            const merged = mergeAndSortHistory(tournaments);
            setHistory(merged);
            saveHistoryToStorage(yr ?? stored.seasonYear ?? null, merged);
            return;
          }

          // Fetch missing tournaments with small concurrency.
          const CONCURRENCY = 2;
          const queue = [...missing];
          const results = [];

          const workers = Array.from({ length: CONCURRENCY }).map(async () => {
            while (queue.length) {
              const item = queue.shift();
              if (!item) break;
              try {
                const yyyymmdd = yyyymmddFromIso(item.endDate);
                const t = await fetchTournamentByDate(yyyymmdd, item.id, item.label);
                if (t) results.push(t);
              } catch (e) {
                console.error(e);
              }
            }
          });

          await Promise.all(workers);

          const merged = mergeAndSortHistory([...tournaments, ...results]);
          setHistory(merged);
          saveHistoryToStorage(yr ?? stored.seasonYear ?? null, merged);
        } finally {
          syncInFlightRef.current = false;
        }
      };

      const autoSaveIfCompleted = (
        eventId,
        name,
        isMajor,
        players,
        completed,
        endDate,
        cal,
        bounds,
        seasonStarted,
        yrFromFetch
      ) => {
        if (!completed) return;
        if (!eventId) return;

        // Fantasy season gating (Phoenix → BMW).
        // Until the Phoenix Open is complete, we intentionally do not save anything.
        if (!bounds || !seasonStarted) return;
        if (!isEventIdInFantasySeason(eventId, cal, bounds)) return;

        const stored = loadHistoryFromStorage();
        let existing = Array.isArray(stored.tournaments) ? stored.tournaments : [];

        // Keep storage clean: only retain tournaments within our fantasy season window.
        existing = existing.filter((t) =>
          isEventIdInFantasySeason(String(t.eventId || t.id || ''), cal, bounds)
        );

        const already = existing.some(
          (t) => String(t.eventId || t.id || '') === String(eventId)
        );
        if (already) return;

        const teams = computeTeamsForTournament(players, isMajor);
        const field = computeFieldForTournament(players, isMajor);
        const t = {
          id: String(eventId),
          eventId: String(eventId),
          name,
          date: endDate || new Date().toISOString(),
          isMajor,
          url: getLeaderboardUrlFromEvent(null, eventId),
          field,
          teams,
        };

        const merged = mergeAndSortHistory([...existing, t]);
        setHistory(merged);
        saveHistoryToStorage(
          yrFromFetch ?? seasonYear ?? stored.seasonYear ?? null,
          merged
        );
      };

      const fetchData = async () => {
        setLoading(true);
        try {
          const res = await fetch(SCOREBOARD_URL);
          const json = await res.json();

          const league = json?.leagues?.[0];
          const yr = league?.season?.year;
          if (yr) setSeasonYear(yr);

          const cal = league?.calendar || [];
          setCalendar(cal);

          const bounds = getFantasySeasonBounds(cal);
          const started = getSeasonStarted(bounds);
          setFantasySeason({ bounds, started });

          if (json?.events?.[0]) {
            const e = json.events[0];
            const name = e.name || 'PGA Tournament';
            const isMajor = isMajorName(name);
            const eventId = String(e.id || '');
            const url = getLeaderboardUrlFromEvent(e, eventId);

            const comp = e.competitions?.[0];
            const comps = comp?.competitors || [];
            const compStatusType = comp?.status?.type || {};
            const compStatusText = [
              compStatusType.detail,
              compStatusType.shortDetail,
              compStatusType.description,
              compStatusType.name,
            ]
              .filter(Boolean)
              .join(' ');
            // IMPORTANT:
            // ESPN's *competition* status may show "Round X - Play Complete" with state="post"
            // even while the tournament is still in progress. For tournament-level state/completion,
            // we must use the EVENT status, not the competition status.
            const eventStatus = e?.status?.type || {};
            const completed = eventStatus?.completed === true || eventStatus?.state === 'post';
            const eventState = eventStatus?.state || '';

            const round = extractRoundFromCompetition(comp);

            // Tournament meta (cutRound) is required to correctly handle:
            // - Standard 36-hole cuts (cutRound=2)
            // - 54-hole cuts (cutRound=3) like The American Express
            // - No-cut events (cutRound=0)
            let cutRound = null;
            let numberOfRounds = null;

            const cachedMeta = cutMetaRef.current[eventId];
            if (cachedMeta) {
              cutRound = cachedMeta.cutRound;
              numberOfRounds = cachedMeta.numberOfRounds;
            } else {
              try {
                const metaRes = await fetch(
                  `${LEADERBOARD_META_URL}?tournamentId=${encodeURIComponent(eventId)}`
                );
                const metaJson = await metaRes.json();
                const metaEvent =
                  (metaJson?.events || []).find(
                    (ev) => String(ev.id) === String(eventId)
                  ) || metaJson?.events?.[0];

                const t = metaEvent?.tournament || {};
                if (t.cutRound !== undefined && t.cutRound !== null)
                  cutRound = Number(t.cutRound);
                if (t.numberOfRounds !== undefined && t.numberOfRounds !== null)
                  numberOfRounds = Number(t.numberOfRounds);

                cutMetaRef.current[eventId] = { cutRound, numberOfRounds };
              } catch (err) {
                console.error(err);
              }
            }

            const inferredCutRound = inferCutRoundFromEventName(name);
            if (
              (cutRound === null ||
                cutRound === undefined ||
                Number.isNaN(Number(cutRound))) &&
              inferredCutRound != null
            ) {
              cutRound = inferredCutRound;
            }

            // Cache the resolved cutRound so we don't repeatedly hit (or fail) the meta endpoint.
            cutMetaRef.current[eventId] = { cutRound, numberOfRounds };

            const cutRoundNum =
              cutRound === 0
                ? 0
                : cutRound != null && !Number.isNaN(Number(cutRound))
                ? Number(cutRound)
                : 2;

            const numberOfRoundsNum =
              numberOfRounds != null && !Number.isNaN(Number(numberOfRounds))
                ? Number(numberOfRounds)
                : null;

            const cutApplied = computeCutApplied({
              completed: !!completed,
              round,
              cutRound: cutRoundNum,
              compStatusText,
              competitors: comps,
            });

            setInfo({
              name,
              isMajor,
              url,
              eventId,
              state: eventState,
              round,
              cutRound: cutRoundNum,
              numberOfRounds: numberOfRoundsNum,
              cutApplied: !!cutApplied,
              completed: !!completed,
            });

            const players = buildPlayersFromCompetitors(
              comps,
              !!completed,
              round,
              cutRoundNum,
              !!cutApplied
            );

            // Only autosave when ESPN marks the event completed.
            autoSaveIfCompleted(
              eventId,
              name,
              isMajor,
              players,
              completed,
              e.endDate || comp?.endDate,
              cal,
              bounds,
              started,
              yr
            );

            setData(players);
            setUpdate(new Date());

            // Keep history current (pull all completed fantasy-season events to-date from ESPN calendar)
            // This is the fix for the "Previous" and "Season" tabs.
            syncHistoryFromCalendar(cal, yr, eventId, bounds, started).catch(console.error);
          }
        } catch (e) {
          console.error(e);
        } finally {
          setLoading(false);
        }
      };

      const sorted = useMemo(() => {
        return [...TEAMS].sort((a, b) => {
          const aScore = getTeamTotalScore(a);
          const bScore = getTeamTotalScore(b);
          return bScore - aScore;
        });
      }, [data, info]);

      const optimalLiveLineup = useMemo(() => {
        const cap = OPTIMAL_LINEUP_SALARY_CAP;
        const size = OPTIMAL_LINEUP_SIZE;

        const liveHasStarted =
          info?.state !== 'pre' && (data || []).some((p) => p.started);

        if (!liveHasStarted) {
          return {
            cap,
            size,
            ready: false,
            best: null,
            note: 'Optimal lineup will appear once play begins.',
          };
        }

        const cutRoundRaw = info?.cutRound;
        const cutRoundNum =
          cutRoundRaw === 0
            ? 0
            : typeof cutRoundRaw === 'number'
            ? cutRoundRaw
            : cutRoundRaw != null
            ? Number(cutRoundRaw)
            : 2;

        const effectiveCutRound =
          typeof cutRoundNum === 'number' && !Number.isNaN(cutRoundNum)
            ? cutRoundNum
            : 2;

        const hasCut = effectiveCutRound > 0;
        const completedLive = !!info?.completed;
        const cutAppliedLive = !!info?.cutApplied;

        // Projection mode is used BEFORE the cut is officially applied.
        const isProjectionMode = hasCut && !completedLive && !cutAppliedLive;

        const candidates = (data || [])
          .map((pl) => {
            if (!pl || pl.withdrawn) return null;

            const key = normalize(pl.name);
            const price = prices?.[key];
            if (!Number.isFinite(price) || price <= 0) return null;

            const salary = Math.round(price);
            if (!Number.isFinite(salary) || salary <= 0 || salary > cap) return null;

            const points = getScore(pl.name, data, info.isMajor);

            const started = pl.started !== false;

            let countsForCut = false;
            if (!started) {
              countsForCut = false;
            } else if (!hasCut) {
              countsForCut = true;
            } else {
              countsForCut = isProjectionMode
                ? !!(pl.posNum && pl.posNum <= PROJECTED_CUT_RANK)
                : !!pl.makingCut;
            }

            return {
              key,
              name: pl.name,
              price: salary,
              points: Number(points || 0),
              countsForCut,
              pos: started ? pl.pos : '—',
              score: started ? pl.score : '—',
            };
          })
          .filter(Boolean);

        if (candidates.length < size) {
          return {
            cap,
            size,
            ready: true,
            best: null,
            note: 'Not enough priced golfers in this field to build an optimal lineup.',
          };
        }

        const maxCuts = size;

        // dp[count][cost][cuts] = max base points
        const dp = Array.from({ length: size + 1 }, () =>
          Array.from({ length: cap + 1 }, () => Array(maxCuts + 1).fill(-Infinity))
        );
        const prev = Array.from({ length: size + 1 }, () =>
          Array.from({ length: cap + 1 }, () => Array(maxCuts + 1).fill(null))
        );

        dp[0][0][0] = 0;

        for (let i = 0; i < candidates.length; i++) {
          const cand = candidates[i];
          const salary = cand.price;
          const pts = cand.points;
          const cut = cand.countsForCut ? 1 : 0;

          for (let cnt = size - 1; cnt >= 0; cnt--) {
            for (let cost = cap - salary; cost >= 0; cost--) {
              for (let c = 0; c <= maxCuts; c++) {
                const cur = dp[cnt][cost][c];
                if (cur === -Infinity) continue;

                const newCuts = c + cut;
                if (newCuts > maxCuts) continue;

                const newCost = cost + salary;
                const newPts = cur + pts;

                if (newPts > dp[cnt + 1][newCost][newCuts]) {
                  dp[cnt + 1][newCost][newCuts] = newPts;
                  prev[cnt + 1][newCost][newCuts] = {
                    prevCost: cost,
                    prevCuts: c,
                    prevCount: cnt,
                    index: i,
                  };
                }
              }
            }
          }
        }

        // Pick best by (base points + cut bonus)
        let bestState = null;
        for (let cost = 0; cost <= cap; cost++) {
          for (let c = 0; c <= maxCuts; c++) {
            const baseScore = dp[size][cost][c];
            if (baseScore === -Infinity) continue;

            const cutBonus = getTeamCutBonusForCount(c);
            const totalScore = baseScore + cutBonus;

            if (
              !bestState ||
              totalScore > bestState.totalScore ||
              (totalScore === bestState.totalScore && baseScore > bestState.baseScore) ||
              (totalScore === bestState.totalScore &&
                baseScore === bestState.baseScore &&
                cost < bestState.totalCost)
            ) {
              bestState = {
                totalCost: cost,
                baseScore,
                cutBonus,
                cutCount: c,
                totalScore,
              };
            }
          }
        }

        if (!bestState) {
          return {
            cap,
            size,
            ready: true,
            best: null,
            note: 'No valid optimal lineup found under the $120 cap with the current price list.',
          };
        }

        // Reconstruct picks
        const picks = [];
        let cost = bestState.totalCost;
        let cuts = bestState.cutCount;
        let cnt = size;

        while (cnt > 0) {
          const step = prev[cnt][cost][cuts];
          if (!step) break;
          const pl = candidates[step.index];
          picks.push(pl);
          cost = step.prevCost;
          cuts = step.prevCuts;
          cnt = step.prevCount;
        }

        picks.reverse();

        return {
          cap,
          size,
          ready: true,
          note: null,
          best: {
            players: picks,
            totalCost: bestState.totalCost,
            remaining: cap - bestState.totalCost,
            baseScore: bestState.baseScore,
            cutCount: bestState.cutCount,
            cutBonus: bestState.cutBonus,
            totalScore: bestState.totalScore,
          },
        };
      }, [data, prices, info]);


      const season = useMemo(() => {
        return TEAMS.map((team) => {
          let total = 0,
            wins = 0,
            top3 = 0;

          let baseTotal = 0;
          let cutBonusTotal = 0;

          const breakdown = (history || [])
            .map((t) => {
              const ts = (t.teams || []).find((x) => x.id === team.id);
              if (!ts) return null;

              const players = ts.players || [];
              const baseScore = players.reduce((s, p) => s + (p?.points || 0), 0);

              const madeCutCount =
                typeof ts.madeCutCount === 'number'
                  ? ts.madeCutCount
                  : players.reduce((n, p) => n + (p?.madeCut ? 1 : 0), 0);

              const cutBonus =
                typeof ts.cutBonus === 'number'
                  ? ts.cutBonus
                  : getTeamCutBonusForCount(madeCutCount);

              const teamScore =
                typeof ts.score === 'number' && !Number.isNaN(ts.score)
                  ? ts.score
                  : baseScore + cutBonus;

              total += teamScore;
              baseTotal += baseScore;
              cutBonusTotal += cutBonus;

              const sortedTeams = [...(t.teams || [])].sort((a, b) => b.score - a.score);
              const pos = sortedTeams.findIndex((x) => x.id === team.id);
              if (pos === 0) wins++;
              if (pos > -1 && pos < 3) top3++;

              return {
                name: t.name,
                score: teamScore,
                baseScore,
                cutBonus,
                madeCutCount,
                pos: pos + 1,
                players,
              };
            })
            .filter(Boolean);

          const playerTotals = team.players.map((playerName) => {
            const pts = breakdown.reduce((sum, t) => {
              const p = (t.players || []).find((x) => x.name === playerName);
              return sum + (p?.points || 0);
            }, 0);
            return { name: playerName, points: pts };
          });

          return {
            ...team,
            total,
            baseTotal,
            cutBonusTotal,
            wins,
            top3,
            avg: history.length ? (total / history.length).toFixed(1) : 0,
            breakdown,
            playerTotals,
          };
        }).sort((a, b) => b.total - a.total);
      }, [history]);

      const importPrices = () => {
        const { map, count } = parsePricesText(priceText);
        if (!count) return;
        const merged = { ...(prices || {}), ...map };
        setPrices(merged);
        savePricesToStorage(merged);
        setPriceText('');
        setPriceImportOpen(false);
      };

      const clearPrices = () => {
        setPrices({});
        savePricesToStorage({});
      };

            const golferStats = useMemo(() => {
        const totals = new Map();

        for (const t of history || []) {
          const field = t?.field;
          if (!Array.isArray(field) || field.length === 0) continue;

          for (const g of field) {
            const key = normalize(g?.name);
            if (!key) continue;

            const prev =
              totals.get(key) || {
                key,
                name: g.name,
                totalPoints: 0,
                events: 0,
                cutsMade: 0,
                tournaments: [],
              };

            const pts = Number(g?.points || 0);
            const madeCut = !!g?.madeCut;

            // Player analytics use only the golfer's own fantasy points
            // (team cut-bonus is NOT allocated to individuals here).
            prev.totalPoints += pts;

            prev.events += 1;
            if (madeCut) prev.cutsMade += 1;

            prev.tournaments.push({
              eventId: t?.eventId || t?.id || t?.name,
              name: t?.name || 'Tournament',
              date: t?.date || null,
              points: pts,
              pos: g?.pos || 'N/A',
              score: g?.score || '-',
              madeCut,
            });

            // Prefer the first seen display name
            if (!prev.name) prev.name = g.name;

            totals.set(key, prev);
          }
        }

        const arr = Array.from(totals.values()).map((x) => ({
          ...x,
          tournaments: (x.tournaments || []).slice().sort((a, b) => {
            const da = a?.date ? new Date(a.date).getTime() : 0;
            const db = b?.date ? new Date(b.date).getTime() : 0;
            return da - db;
          }),
          avgPoints: x.events ? x.totalPoints / x.events : 0,
          price: prices?.[x.key] ?? null,
        }));

        arr.sort((a, b) => b.totalPoints - a.totalPoints);
        return arr;
      }, [history, prices]);

      const leagueAvgRoi = useMemo(() => {
        // League-wide average points-per-dollar (Season Points ÷ Price), weighted by starts.
        const priced = (golferStats || [])
          .map((g) => {
            const price = Number(g.price);
            const starts = Number(g.events || 0);
            const hasPrice = Number.isFinite(price) && price > 0;
            if (!hasPrice || starts <= 0) return null;

            const roi = Number(g.totalPoints || 0) / price;
            if (!Number.isFinite(roi)) return null;

            return { roi, starts };
          })
          .filter(Boolean);

        const totalW = priced.reduce((s, x) => s + x.starts, 0);
        if (!totalW) return 0;

        const total = priced.reduce((s, x) => s + x.roi * x.starts, 0);
        return total / totalW;
      }, [golferStats]);

      const golferValue = useMemo(() => {
        // Adj Value = points per dollar, with an "experience adjustment" so one big week doesn't dominate.
        // ROI = Season Points ÷ Price
        // Weight w = Starts / (Starts + BAYES_K)
        // Adj Value = w*ROI + (1-w)*LeagueAvgROI
        const arr = (golferStats || [])
          .map((g) => {
            const price = Number(g.price);
            const starts = Number(g.events || 0);
            const hasPrice = Number.isFinite(price) && price > 0;

            if (!hasPrice) {
              return { ...g, price: null, starts, roi: null, bayesValue: null, weight: null };
            }

            const roi = Number(g.totalPoints || 0) / price;
            if (!Number.isFinite(roi) || starts <= 0) {
              return { ...g, price, starts, roi: null, bayesValue: null, weight: null };
            }

            const w = starts / (starts + BAYES_K);
            const bayesValue = w * roi + (1 - w) * leagueAvgRoi;

            return {
              ...g,
              price,
              starts,
              roi,
              bayesValue,
              weight: w,
            };
          })
          .filter((g) => g.price && g.bayesValue != null);

        arr.sort((a, b) => b.bayesValue - a.bayesValue);
        return arr;
      }, [golferStats, leagueAvgRoi]);const optimalLineup = useMemo(() => {
  const cap = OPTIMAL_LINEUP_SALARY_CAP;
  const size = OPTIMAL_LINEUP_SIZE;

  const candidates = (golferValue || [])
    .map((g) => ({
      key: g.key,
      name: g.name,
      price: Number(g.price),
      points: Number(g.totalPoints || 0),
      starts: Number(g.starts || g.events || 0),
      bayesValue: Number(g.bayesValue || 0),
    }))
    .filter((g) => Number.isFinite(g.price) && g.price > 0);

  if (candidates.length === 0) {
    return {
      cap,
      size,
      best: null,
      alternatives: [],
      note: 'No priced golfers found for the current season window.',
    };
  }

  // Limit search space for speed while still allowing a true optimal solution.
  // (We keep the top golfers by season points; with a $120 cap this is more than enough.)
  const MAX_CANDIDATES = 260;
  candidates.sort((a, b) => b.points - a.points);
  const pool = candidates.slice(0, Math.min(MAX_CANDIDATES, candidates.length));

  // 0/1 knapsack with an exact lineup size (6 golfers) and a salary cap.
  // Objective: maximize total season points.
  // Tie-breaker: maximize sum of adjusted values.
  const dpPts = Array.from({ length: size + 1 }, () =>
    Array(cap + 1).fill(-Infinity)
  );
  const dpTie = Array.from({ length: size + 1 }, () =>
    Array(cap + 1).fill(-Infinity)
  );
  const prev = Array.from({ length: size + 1 }, () =>
    Array(cap + 1).fill(null)
  );

  dpPts[0][0] = 0;
  dpTie[0][0] = 0;

  for (let i = 0; i < pool.length; i++) {
    const salary = Math.round(pool[i].price);
    const pts = pool[i].points;
    const tie = Number.isFinite(pool[i].bayesValue) ? pool[i].bayesValue : 0;

    if (!Number.isFinite(salary) || salary <= 0 || salary > cap) continue;

    for (let cnt = size - 1; cnt >= 0; cnt--) {
      for (let cost = cap - salary; cost >= 0; cost--) {
        if (dpPts[cnt][cost] === -Infinity) continue;

        const newCost = cost + salary;
        const newPts = dpPts[cnt][cost] + pts;
        const newTie = dpTie[cnt][cost] + tie;

        const curPts = dpPts[cnt + 1][newCost];
        const curTie = dpTie[cnt + 1][newCost];

        if (newPts > curPts || (newPts === curPts && newTie > curTie)) {
          dpPts[cnt + 1][newCost] = newPts;
          dpTie[cnt + 1][newCost] = newTie;
          prev[cnt + 1][newCost] = { prevCost: cost, prevCount: cnt, index: i };
        }
      }
    }
  }

  const reconstruct = (endCost) => {
    const picks = [];
    let cost = endCost;
    let cnt = size;

    while (cnt > 0) {
      const step = prev[cnt][cost];
      if (!step) return null;
      const pl = pool[step.index];
      picks.push(pl);
      cost = step.prevCost;
      cnt = step.prevCount;
    }

    picks.reverse();
    if (picks.length !== size) return null;
    return picks;
  };

  // Build candidate best lineups for *each* possible cost <= cap.
  // This gives us a solid "top few" list (best at each cost) without needing to store every 2nd-best state.
  const lineups = [];
  for (let cost = 0; cost <= cap; cost++) {
    const pts = dpPts[size][cost];
    if (pts === -Infinity) continue;

    const picks = reconstruct(cost);
    if (!picks) continue;

    const totalCost = picks.reduce((s, p) => s + Math.round(p.price), 0);
    const totalPoints = picks.reduce((s, p) => s + p.points, 0);
    const totalAdj = picks.reduce(
      (s, p) => s + (Number.isFinite(p.bayesValue) ? p.bayesValue : 0),
      0
    );

    const key = picks.map((p) => p.key).join('|');

    lineups.push({
      key,
      players: picks,
      totalCost,
      totalPoints,
      totalAdj,
      remaining: cap - totalCost,
    });
  }

  if (lineups.length === 0) {
    return {
      cap,
      size,
      best: null,
      alternatives: [],
      note: 'No valid 6-player lineup found under the cap with the current price list.',
    };
  }

  // Rank lineups by points, then adjusted value, then lower cost.
  lineups.sort((a, b) => {
    if (b.totalPoints !== a.totalPoints) return b.totalPoints - a.totalPoints;
    if (b.totalAdj !== a.totalAdj) return b.totalAdj - a.totalAdj;
    return a.totalCost - b.totalCost;
  });

  // Deduplicate by key (should already be unique by cost, but keep safe).
  const seen = new Set();
  const unique = [];
  for (const lu of lineups) {
    if (seen.has(lu.key)) continue;
    seen.add(lu.key);
    unique.push(lu);
    if (unique.length >= 8) break; // 1 best + 7 alternates max
  }

  const best = unique[0] || null;
  const alternatives = unique.slice(1, 6); // show the next 5

  return {
    cap,
    size,
    best,
    alternatives,
    note: null,
  };
}, [golferValue]);

      const searchKey = useMemo(() => normalize(search).trim(), [search]);

      const teamMatchesSearch = (team) => {
        if (!searchKey) return true;
        const name = team?.name || '';
        const playersArr = Array.isArray(team?.players) ? team.players : [];
        const playerNames = playersArr
          .map((p) => (typeof p === 'string' ? p : p?.name || ''))
          .join(' ');
        const hay = normalize(`${name} ${playerNames}`);
        return hay.includes(searchKey);
      };

      const tournamentMatchesSearch = (t) => {
        if (!searchKey) return true;
        return normalize(t?.name || '').includes(searchKey);
      };

      const golferMatchesSearch = (g) => {
        if (!searchKey) return true;
        return normalize(g?.name || '').includes(searchKey);
      };

      return (
        <div className="min-h-screen golf-bg p-3 sm:p-4 relative overflow-hidden tabular-nums">
          <div className="golf-dimples absolute inset-0"></div>
          <div className="max-w-7xl mx-auto relative">
            
            <div className="flex items-center justify-center gap-3 mb-6">
              <div className="w-10 h-10 rounded-full bg-white/15 ring-1 ring-white/25 flex items-center justify-center shadow">
                <span className="text-2xl">⛳</span>
              </div>
              <div className="text-left">
                <div className="text-white font-extrabold text-3xl sm:text-4xl tracking-tight drop-shadow leading-tight">JTFantasy Golf</div>
                <div className="text-white/80 text-xs sm:text-sm font-semibold tracking-wide">Live leaderboards • Cut-line scoring</div>
              </div>

            </div>
            <div className="glass rounded-2xl shadow-2xl p-2 mb-4 sm:mb-6">
              <div className="grid grid-cols-2 gap-2 sm:flex sm:gap-2">
                {[
                  ['live', 'Current Tournament'],
                  ['history', 'Previous Tournaments'],
                  ['season', 'Season Long Standings'],
                  ['stats', 'Player Stats & Analytics'],
                ].map(([k, l]) => (
                  <button
                    key={k}
                    onClick={() => {
                      setTab(k);
                      setSelected(null);
                    }}
                    className={`w-full sm:flex-1 px-3 py-2 sm:px-4 sm:py-3 text-sm sm:text-base rounded-xl font-bold transition-all duration-200 ${
                      tab === k
                        ? 'bg-gradient-to-r from-emerald-600 to-teal-600 text-white shadow-lg ring-2 ring-white/30'
                        : 'bg-white/60 text-gray-800 hover:bg-white/80'
                    }`}
                  >
                    {l}
                  </button>
                ))}
              </div>
            </div>


            <div className="glass rounded-2xl shadow-xl p-2 mb-4 sm:mb-6">
              <div className="flex items-center gap-2 px-3 py-2">
                <span className="text-gray-500 text-sm">🔎</span>
                <input
                  value={search}
                  onChange={(e) => setSearch(e.target.value)}
                  placeholder={
                    tab === 'stats'
                      ? 'Search golfers…'
                      : tab === 'history' && !selected
                      ? 'Search tournaments…'
                      : tab === 'history' && selected
                      ? 'Search lineups…'
                      : 'Search lineups or golfers…'
                  }
                  className="w-full bg-transparent outline-none text-sm sm:text-base font-semibold text-gray-900 placeholder-gray-500"
                />
                {search && (
                  <button
                    onClick={() => setSearch('')}
                    className="text-gray-500 hover:text-gray-900 font-bold px-2"
                    aria-label="Clear search"
                    title="Clear"
                  >
                    ✕
                  </button>
                )}
              </div>
            </div>

            {tab === 'live' && (
              <>
                <div className="live-hero rounded-2xl shadow-2xl p-3 sm:p-6 mb-3 sm:mb-5">
                  <div className="flex justify-between items-start flex-wrap gap-4">
                    <div>
                      <h1 className="text-2xl sm:text-4xl font-bold text-white">{info.name}</h1>
                      {info.isMajor && (
                        <span className="inline-block mt-2 px-3 py-1 bg-red-600 text-white text-sm font-bold rounded-full">
                          MAJOR
                        </span>
                      )}
                      {info.completed || info.state === 'post' ? (
                        <span className="inline-block mt-2 ml-2 px-3 py-1 bg-emerald-600 text-white text-sm font-bold rounded-full">
                          ✓ COMPLETED
                        </span>
                      ) : data.length === 0 || !data.some((p) => p.started) ? (
                        <span className="inline-block mt-2 ml-2 px-3 py-1 bg-blue-600 text-white text-sm font-bold rounded-full">
                          ⏰ NOT STARTED
                        </span>
                      ) : (
                        <span className="inline-block mt-2 ml-2 px-3 py-1 bg-yellow-400 text-gray-900 text-sm font-extrabold rounded-full">
                          ✓ IN PROGRESS
                        </span>
                      )}
                      {info.url && (
                        <a
                          href={info.url}
                          target="_blank"
                          className="inline-block mt-2 sm:mt-3 px-3 sm:px-4 py-1.5 sm:py-2 rounded-lg font-semibold text-sm shadow border border-white/25 bg-white/10 text-white hover:bg-white/15 backdrop-blur"
                          rel="noreferrer"
                        >
                          📊 ESPN Leaderboard →
                        </a>
                      )}
                    </div>
                  </div>

                {(() => {
                  const best = optimalLiveLineup?.best;
                  const cap = optimalLiveLineup?.cap ?? OPTIMAL_LINEUP_SALARY_CAP;

                  const optimalObj = {
                    name: 'Optimal $120 Lineup',
                    players: (best?.players || []).map((p) => p.name),
                  };

                  const show = !searchKey || teamMatchesSearch(optimalObj);
                  if (!show) return null;

                  const isExp = expanded['l-optimal'];

                  return (
                    <div className="glass rounded-2xl shadow-2xl overflow-hidden border border-white/40">
                      <div
                        onClick={() => toggle('l-optimal')}
                        className={`bg-gradient-to-r from-slate-900 via-emerald-900 to-teal-900 ${c(
                          'px-3 py-2',
                          'px-5 py-4'
                        )} text-white cursor-pointer hover:opacity-95`}
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-4 min-w-0">
                            <div
                              className={`bg-white text-gray-900 rounded-full ${c(
                                'w-8 h-8 text-base',
                                'w-10 h-10 text-lg'
                              )} flex items-center justify-center font-bold shadow`}
                            >
                              ⭐
                            </div>
                            <div className="min-w-0">
                              <h2
                                className={`${c(
                                  'text-lg',
                                  'text-xl'
                                )} font-extrabold truncate`}
                              >
                                Optimal $120 Lineup
                              </h2>
                              {best ? (
                                <div className="text-xs sm:text-sm text-white/80 font-semibold truncate">
                                  ${best.totalCost}/{cap} cap • {best.cutCount} in cut line
                                </div>
                              ) : (
                                <div className="text-xs sm:text-sm text-white/80 font-semibold truncate">
                                  {optimalLiveLineup?.note || 'Calculating…'}
                                </div>
                              )}
                            </div>
                          </div>
                          <div className="flex items-center gap-4">
                            <div
                              className={`${c(
                                'text-2xl',
                                'text-3xl'
                              )} font-bold score-num`}
                            >
                              {best ? best.totalScore : 0}
                            </div>
                            <div className="text-2xl">{isExp ? '▼' : '▶'}</div>
                          </div>
                        </div>
                      </div>

                      {isExp && (
                        <div className={`${c('p-3', 'p-4')} overflow-x-auto`}>
                          {best ? (
                            <table className="w-full min-w-[520px]">
                              <thead>
                                <tr className="border-b-2 border-gray-300">
                                  <th
                                    className={`text-left ${c(
                                      'py-1.5 px-2 text-xs',
                                      'py-2 px-2 text-sm'
                                    )} font-bold text-gray-700`}
                                  >
                                    Player
                                  </th>
                                  <th
                                    className={`text-center ${c(
                                      'py-1.5 px-2 text-xs',
                                      'py-2 px-2 text-sm'
                                    )} font-bold text-gray-700`}
                                  >
                                    Pos
                                  </th>
                                  <th
                                    className={`text-center ${c(
                                      'py-1.5 px-2 text-xs',
                                      'py-2 px-2 text-sm'
                                    )} font-bold text-gray-700`}
                                  >
                                    Score
                                  </th>
                                  <th
                                    className={`text-right ${c(
                                      'py-1.5 px-2 text-xs',
                                      'py-2 px-2 text-sm'
                                    )} font-bold text-gray-700`}
                                  >
                                    Points
                                  </th>
                                </tr>
                              </thead>
                              <tbody>
                                {(best.players || []).map((p, idx) => (
                                  <tr
                                    key={p.key || idx}
                                    className="border-b border-gray-200 hover:bg-blue-50"
                                  >
                                    <td
                                      className={`px-2 font-semibold text-gray-900 ${c(
                                        'py-2 text-xs',
                                        'py-3 text-sm'
                                      )}`}
                                    >
                                      {p.name}{' '}
                                      <span className="text-gray-500 font-bold">
                                        (${p.price})
                                      </span>
                                    </td>
                                    <td
                                      className={`text-center px-2 font-semibold text-black ${c(
                                        'py-2 text-xs',
                                        'py-3 text-sm'
                                      )}`}
                                    >
                                      {p.pos || 'N/A'}
                                    </td>
                                    <td
                                      className={`text-center px-2 font-semibold text-black ${c(
                                        'py-2 text-xs',
                                        'py-3 text-sm'
                                      )}`}
                                    >
                                      {p.score || '-'}
                                    </td>
                                    <td
                                      className={`text-right px-2 font-bold text-green-600 score-num ${c(
                                        'py-2 text-base',
                                        'py-3 text-xl'
                                      )}`}
                                    >
                                      {p.points}
                                    </td>
                                  </tr>
                                ))}
                                <tr className="border-t-2 border-gray-300 bg-gray-50">
                                  <td
                                    colSpan={3}
                                    className={`px-2 font-bold text-gray-700 ${c(
                                      'py-2 text-xs',
                                      'py-3 text-sm'
                                    )}`}
                                  >
                                    Player Points
                                  </td>
                                  <td
                                    className={`text-right px-2 font-bold text-gray-900 ${c(
                                      'py-2 text-xs',
                                      'py-3 text-sm'
                                    )}`}
                                  >
                                    {best.baseScore}
                                  </td>
                                </tr>
                                <tr className="bg-gray-50">
                                  <td
                                    colSpan={3}
                                    className={`px-2 font-bold text-gray-700 ${c(
                                      'py-2 text-xs',
                                      'py-3 text-sm'
                                    )}`}
                                  >
                                    Cut Bonus ({best.cutCount} in cut line)
                                  </td>
                                  <td
                                    className={`text-right px-2 font-bold text-green-700 ${c(
                                      'py-2 text-xs',
                                      'py-3 text-sm'
                                    )}`}
                                  >
                                    +{best.cutBonus}
                                  </td>
                                </tr>
                                <tr className="bg-gray-50">
                                  <td
                                    colSpan={3}
                                    className={`px-2 font-bold text-gray-700 ${c(
                                      'py-2 text-xs',
                                      'py-3 text-sm'
                                    )}`}
                                  >
                                    Total Cost
                                  </td>
                                  <td
                                    className={`text-right px-2 font-bold text-gray-900 ${c(
                                      'py-2 text-xs',
                                      'py-3 text-sm'
                                    )}`}
                                  >
                                    ${best.totalCost} (rem {best.remaining})
                                  </td>
                                </tr>
                              </tbody>
                            </table>
                          ) : (
                            <div className="text-sm text-gray-700 font-semibold">
                              {optimalLiveLineup?.note ||
                                'Optimal lineup will appear once play begins.'}
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  );
                })()}

                </div>
                <div className={compact ? "space-y-2" : "space-y-3"}>
                  {sorted
                    .map((team, idx) => ({ team, idx }))
                    .filter(({ team }) => teamMatchesSearch(team))
                    .map(({ team, idx }) => {
                    const baseScore = (team.players || []).reduce((s, name) => s + getScore(name), 0);
                    const madeCutCount = getMadeCutCountForTeam(team, data);
                    const cutBonus = getTeamCutBonusForCount(madeCutCount);
                    const teamScore = baseScore + cutBonus;
                    const colors = [
                      'from-yellow-500 to-yellow-600',
                      'from-gray-400 to-gray-600',
                      'from-orange-500 to-orange-700',
                    ];
                    const rank = idx + 1;
                    const podiumIdx = rank - 1;
                    const isPodium = rank <= 3;
                    const isExp = expanded[`l-${team.id}`];

                    return (
                      <div
                        key={team.id}
                        className="glass rounded-2xl shadow-2xl overflow-hidden"
                      >
                        <div
                          onClick={() => toggle(`l-${team.id}`)}
                          className={`${isPodium ? 'bg-gradient-to-r ' + colors[podiumIdx] : 'bg-gray-100'} ${c('px-3 py-2','px-5 py-4')} ${isPodium ? 'text-white' : 'text-gray-900'} cursor-pointer hover:opacity-90`}
                        >
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-4 min-w-0">
                              <div className={`bg-white text-gray-900 rounded-full ${c('w-8 h-8 text-base','w-10 h-10 text-lg')} flex items-center justify-center font-bold shadow`}>
                                {rank === 1 ? '🏆' : rank}
                              </div>
                              <h2 className={`${c('text-lg','text-xl')} font-bold truncate`}>
                                {team.name}
                              </h2>
                            </div>
                            <div className="flex items-center gap-4">
                              <div className={`${c('text-2xl','text-3xl')} font-bold score-num`}>
                                {teamScore}
                              </div>
                              <div className="text-2xl">
                                {isExp ? '▼' : '▶'}
                              </div>
                            </div>
                          </div>
                        </div>

                        {isExp && (
                          <div className={`${c("p-3","p-4")} overflow-x-auto`}>
                            <table className="w-full min-w-[520px]">
                              <thead>
                                <tr className="border-b-2 border-gray-300">
                                  <th className={`text-left ${c("py-1.5 px-2 text-xs","py-2 px-2 text-sm")} font-bold text-gray-700`}>
                                    Player
                                  </th>
                                  <th className={`text-center ${c("py-1.5 px-2 text-xs","py-2 px-2 text-sm")} font-bold text-gray-700`}>
                                    Pos
                                  </th>
                                  <th className={`text-center ${c("py-1.5 px-2 text-xs","py-2 px-2 text-sm")} font-bold text-gray-700`}>
                                    Score
                                  </th>
                                  <th className={`text-right ${c("py-1.5 px-2 text-xs","py-2 px-2 text-sm")} font-bold text-gray-700`}>
                                    Points
                                  </th>
                                </tr>
                              </thead>
                              <tbody>
                                {team.players.map((p, idx) => {
                                  const player = findPlayer(p, data);
                                  const pts = getScore(p);
                                  return (
                                    <tr
                                      key={idx}
                                      className="border-b border-gray-200 hover:bg-blue-50"
                                    >
                                      <td className={`px-2 font-semibold text-gray-900 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                        {p}
                                      </td>
                                      <td className={`text-center px-2 font-semibold ${c("py-2 text-xs","py-3 text-sm")}`}>
                                        {player?.pos || 'N/A'}
                                      </td>
                                      <td className={`text-center px-2 font-semibold ${c("py-2 text-xs","py-3 text-sm")}`}>
                                        {player?.score || '-'}
                                      </td>
                                      <td className={`text-right px-2 font-bold text-green-600 score-num ${c("py-2 text-base","py-3 text-xl")}`}>
                                        {pts}
                                      </td>
                                    </tr>
                                  );
                                })}
                                <tr className="border-t-2 border-gray-300 bg-gray-50">
                                  <td colSpan={3} className={`px-2 font-bold text-gray-700 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                    Player Points
                                  </td>
                                  <td className={`text-right px-2 font-bold text-gray-900 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                    {baseScore}
                                  </td>
                                </tr>
                                <tr className="bg-gray-50">
                                  <td colSpan={3} className={`px-2 font-bold text-gray-700 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                    Cut Bonus ({madeCutCount} in cut line)
                                  </td>
                                  <td className={`text-right px-2 font-bold text-green-700 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                    +{cutBonus}
                                  </td>
                                </tr>
                              </tbody>
                            </table>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </>
            )}

            {tab === 'history' && !selected && (
              <div className="glass rounded-2xl shadow-2xl p-4 sm:p-8">
                <h2 className="text-3xl font-bold text-gray-900 mb-6">📅 Tournament History</h2>
                {history.length === 0 ? (
                  <div className="text-center py-12">
                    {fantasySeason?.bounds && !fantasySeason?.started ? (
                      <>
                        <p className="text-xl text-gray-700 font-bold">
                          Fantasy season has not started yet
                        </p>
                        <p className="text-sm text-gray-600 mt-2">
                          This league only counts tournaments from{' '}
                          <strong>{fantasySeason.bounds.start.label}</strong> through{' '}
                          <strong>{fantasySeason.bounds.end.label}</strong>. History will
                          populate after{' '}
                          <strong>{fantasySeason.bounds.start.label}</strong> is complete.
                        </p>
                      </>
                    ) : fantasySeason?.bounds && fantasySeason?.started ? (
                      <p className="text-xl text-gray-600">No tournament data yet</p>
                    ) : (
                      <p className="text-xl text-gray-600">Loading season window…</p>
                    )}
                  </div>
                ) : (
                  <div className={compact ? "space-y-2" : "space-y-3"}>
                    {[...history]
                      .slice()
                      .reverse()
                      .filter(tournamentMatchesSearch)
                      .map((t) => (
                        <div
                          key={t.id}
                          onClick={() => setSelected(t)}
                          className="border-2 border-gray-200 rounded-xl p-6 hover:border-blue-500 hover:shadow-lg transition cursor-pointer"
                        >
                          <div className="flex justify-between items-center mb-4">
                            <div>
                              <h3 className="font-bold text-2xl text-gray-900">{t.name}</h3>
                              <p className="text-sm text-gray-600">{new Date(t.date).toLocaleDateString()}</p>
                            </div>
                            {t.isMajor && (
                              <span className="px-3 py-1 bg-red-600 text-white text-sm font-bold rounded-full">MAJOR</span>
                            )}
                          </div>
                          <div className="grid grid-cols-3 gap-4 mt-4 pt-4 border-t">
                            {[...(t.teams || [])]
                              .sort((a, b) => b.score - a.score)
                              .slice(0, 3)
                              .map((team, idx) => (
                                <div
                                  key={team.id}
                                  className={`p-4 rounded-lg ${
                                    idx === 0
                                      ? 'bg-yellow-100 border-2 border-yellow-400'
                                      : idx === 1
                                      ? 'bg-gray-100 border-2 border-gray-300'
                                      : 'bg-orange-100 border-2 border-orange-300'
                                  }`}
                                >
                                  <div className="flex items-center gap-2 mb-1">
                                    <span className="text-2xl">{idx === 0 ? '🥇' : idx === 1 ? '🥈' : '🥉'}</span>
                                    <span className="font-bold text-gray-900">{team.name}</span>
                                  </div>
                                  <p className="text-3xl font-bold text-green-600 score-num">{team.score}</p>
                                </div>
                              ))}
                          </div>
                        </div>
                      ))}
                  </div>
                )}
              </div>
            )}

            {tab === 'history' && selected && (
              <div>
                <div className="glass rounded-2xl shadow-2xl p-6 mb-6">
                  <button
                    onClick={() => setSelected(null)}
                    className="text-blue-600 hover:text-blue-800 font-bold mb-4"
                  >
                    ← Back
                  </button>
                  <div className="flex justify-between items-center">
                    <div>
                      <h2 className="text-3xl font-bold text-gray-900">{selected.name}</h2>
                      <p className="text-gray-600">{new Date(selected.date).toLocaleDateString()}</p>
                    </div>
                    {/* Delete button intentionally removed (factual performance leaderboard) */}
                  </div>
                </div>
                <div className="space-y-2">
                  {[...(selected.teams || [])]
                    .sort((a, b) => b.score - a.score)
                    .map((t, idx) => ({ t, idx }))
                    .filter(({ t }) => teamMatchesSearch(t))
                    .map(({ t, idx }) => {
                      const baseScore = (t.players || []).reduce((s, p) => s + (p.points || 0), 0);
                      const madeCutCount =
                        typeof t.madeCutCount === 'number'
                          ? t.madeCutCount
                          : (t.players || []).reduce((n, p) => n + (p.madeCut ? 1 : 0), 0);
                      const cutBonus =
                        typeof t.cutBonus === 'number'
                          ? t.cutBonus
                          : getTeamCutBonusForCount(madeCutCount);
                      const colors = [
                        'from-yellow-400 to-amber-500',
                        'from-gray-300 to-gray-400',
                        'from-orange-500 to-orange-600',
                      ];
                      const rank = idx + 1;
                      const podiumIdx = rank - 1;
                      const isPodium = rank <= 3;
                      const isExp = expanded[`h-${t.id}`];
                      return (
                        <div key={t.id} className="glass rounded-2xl shadow-xl overflow-hidden">
                          <div
                            onClick={() => toggle(`h-${t.id}`)}
                            className={`${isPodium ? 'bg-gradient-to-r ' + colors[podiumIdx] : 'bg-gray-100'} ${c('px-3 py-2','px-5 py-4')} ${isPodium ? 'text-white' : 'text-gray-900'} cursor-pointer hover:opacity-90`}
                          >
                            <div className="flex items-center justify-between">
                              <div className="flex items-center gap-4">
                                <div className="bg-white text-gray-900 rounded-full w-10 h-10 flex items-center justify-center text-lg font-bold">
                                  {rank}
                                </div>
                                <h3 className="text-xl font-bold truncate">{t.name}</h3>
                              </div>
                              <div className="flex items-center gap-4">
                                <div className="text-3xl font-bold">{t.score}</div>
                                <div className="text-xl">{isExp ? '▼' : '▶'}</div>
                              </div>
                            </div>
                          </div>
                          {isExp && (
                            <div className="p-4 sm:p-6 bg-gray-50 overflow-x-auto">
                              <table className="w-full min-w-[520px]">
                                <thead>
                                  <tr className="border-b-2">
                                    <th className="text-left py-2 px-2 font-bold">Player</th>
                                    <th className="text-center py-2 px-2 font-bold">Pos</th>
                                    <th className="text-center py-2 px-2 font-bold">Score</th>
                                    <th className="text-right py-2 px-2 font-bold">Points</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {(t.players || []).map((p, idx) => (
                                    <tr key={idx} className="border-b">
                                      <td className="py-3 px-2 font-semibold">{p.name}</td>
                                      <td className="text-center py-3 px-2">{p.pos}</td>
                                      <td className="text-center py-3 px-2">{p.score}</td>
                                      <td className="text-right py-3 px-2 font-bold text-green-600 text-lg">{p.points}</td>
                                    </tr>
                                  ))}
                                  <tr className="border-t-2 border-gray-300 bg-white/60">
                                    <td colSpan={3} className={`px-2 font-bold text-gray-700 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                      Player Points
                                    </td>
                                    <td className={`text-right px-2 font-bold text-gray-900 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                      {baseScore}
                                    </td>
                                  </tr>
                                  <tr className="bg-white/60">
                                    <td colSpan={3} className={`px-2 font-bold text-gray-700 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                      Cut Bonus ({madeCutCount} made cut)
                                    </td>
                                    <td className={`text-right px-2 font-bold text-green-700 ${c("py-2 text-xs","py-3 text-sm")}`}>
                                      +{cutBonus}
                                    </td>
                                  </tr>
                                </tbody>
                              </table>
                            </div>
                          )}
                        </div>
                      );
                    })}
                </div>
              </div>
            )}

            {tab === 'season' && (
              <div className="glass rounded-2xl shadow-2xl p-4 sm:p-8">
                <h2 className="text-3xl font-bold text-gray-900 mb-6">📊 Season Standings</h2>
                {history.length === 0 ? (
                  <div className="text-center py-12">
                    {fantasySeason?.bounds && !fantasySeason?.started ? (
                      <>
                        <p className="text-xl text-gray-700 font-bold">
                          Fantasy season has not started yet
                        </p>
                        <p className="text-sm text-gray-600 mt-2">
                          Season standings begin after{' '}
                          <strong>{fantasySeason.bounds.start.label}</strong> is complete
                          and run through{' '}
                          <strong>{fantasySeason.bounds.end.label}</strong>.
                        </p>
                      </>
                    ) : fantasySeason?.bounds && fantasySeason?.started ? (
                      <p className="text-xl text-gray-600">No tournament data yet</p>
                    ) : (
                      <p className="text-xl text-gray-600">Loading season window…</p>
                    )}
                  </div>
                ) : (
                  <>
                    <div className="mb-4 inline-flex items-center gap-2 text-xs text-gray-700 bg-white/70 border border-gray-200 rounded-xl px-3 py-2">
                      <span className="font-semibold">Tournaments:</span>
                      <span className="score-num">{history.length}</span>
                    </div>
                    <div className="space-y-4">
                      {season
                        .map((team, idx) => ({ team, idx }))
                        .filter(({ team }) => teamMatchesSearch(team))
                        .map(({ team, idx }) => {
                        const colors = [
                          'from-yellow-500 to-yellow-600',
                          'from-gray-400 to-gray-500',
                          'from-orange-500 to-orange-600',
                        ];
                        const rank = idx + 1;
                        const podiumIdx = rank - 1;
                        const isPodium = rank <= 3;
                        const isExp = expanded[`s-${team.id}`];
                        return (
                          <div key={team.id} className="glass rounded-2xl shadow-xl overflow-hidden">
                            <div
                              onClick={() => toggle(`s-${team.id}`)}
                              className={`${isPodium ? 'bg-gradient-to-r ' + colors[podiumIdx] : 'bg-gray-100'} ${c('px-3 py-2','px-5 py-4')} ${isPodium ? 'text-white' : 'text-gray-900'} cursor-pointer hover:opacity-90`}
                            >
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-6">
                                  <div className={`bg-white text-gray-900 rounded-full ${c('w-8 h-8 text-base','w-10 h-10 text-lg')} flex items-center justify-center font-bold shadow`}>
                                    {rank === 1 ? '👑' : rank}
                                  </div>
                                  <div className="min-w-0">
                                    <h3 className={`${c('text-lg','text-xl')} font-bold truncate`}>{team.name}</h3>
                                    <div className={`mt-0.5 flex flex-wrap gap-3 text-[11px] ${isPodium ? 'text-white/90' : 'text-gray-600'}`}>
                                    <span>🏆 {team.wins} Wins</span>
                                    <span>🥉 {team.top3} Top 3</span>
                                    <span>📊 {team.avg} Avg</span>
                                  </div>
                                </div>
                                </div>
                                <div className="flex items-center gap-6">
                                  <div className="text-right">
                                    <div className={`${c('text-2xl','text-3xl')} font-bold score-num`}>{team.total}</div>
                                    <div className="text-xs opacity-90">Season Pts</div>
                                  </div>
                                  <div className="text-2xl">{isExp ? '▼' : '▶'}</div>
                                </div>
                              </div>
                            </div>
                            {isExp && (
                              <div className={`${c("p-3","p-4")} bg-gray-50`}>
                                <div className="overflow-hidden rounded-xl border border-gray-200 bg-white">
                                  <table className="w-full">
                                    <thead>
                                      <tr className="border-b border-gray-200 bg-gray-50">
                                        <th className={`text-left ${c("py-1.5 px-2 text-xs","py-2 px-2 text-sm")} font-bold text-gray-700`}>
                                          Player
                                        </th>
                                        <th className={`text-right ${c("py-1.5 px-2 text-xs","py-2 px-2 text-sm")} font-bold text-gray-700`}>
                                          Season Pts
                                        </th>
                                      </tr>
                                    </thead>
                                    <tbody>
                                      {team.playerTotals
                                        .slice()
                                        .sort((a, b) => b.points - a.points)
                                        .map((p, pidx) => (
                                          <tr key={pidx} className="border-b border-gray-100 hover:bg-blue-50">
                                            <td className={`px-2 ${c("py-1.5 text-xs","py-2 text-sm")} font-semibold text-gray-900`}>
                                              {p.name}
                                            </td>
                                            <td className={`text-right px-2 ${c("py-1.5 text-xs","py-2 text-sm")} font-bold text-green-700 score-num`}>
                                              {p.points}
                                            </td>
                                          </tr>
                                        ))}

                                      <tr className="bg-gray-50">
                                        <td className={`px-2 ${c("py-2 text-xs","py-2.5 text-sm")} font-bold text-gray-700`}>
                                          Player Points
                                        </td>
                                        <td className={`text-right px-2 ${c("py-2 text-xs","py-2.5 text-sm")} font-bold text-gray-900 score-num`}>
                                          {team.baseTotal}
                                        </td>
                                      </tr>
                                      <tr className="bg-gray-50">
                                        <td className={`px-2 ${c("py-2 text-xs","py-2.5 text-sm")} font-bold text-gray-700`}>
                                          Cut Bonus (season total)
                                        </td>
                                        <td className={`text-right px-2 ${c("py-2 text-xs","py-2.5 text-sm")} font-bold text-green-700 score-num`}>
                                          +{team.cutBonusTotal}
                                        </td>
                                      </tr>
                                      <tr className="bg-gray-100 border-t-2 border-gray-300">
                                        <td className={`px-2 ${c("py-2 text-xs","py-2.5 text-sm")} font-bold text-gray-800`}>
                                          Season Total
                                        </td>
                                        <td className={`text-right px-2 ${c("py-2 text-xs","py-2.5 text-sm")} font-bold text-gray-900 score-num`}>
                                          {team.total}
                                        </td>
                                      </tr>
                                    </tbody>
                                  </table>
                                </div>

                                <div className="mt-4">
                                  <h4 className="font-bold text-sm mb-2">Tournament Breakdown</h4>
                                  <div className="space-y-2">
                                    {team.breakdown.map((tb, idx) => {
                                      const tKey = `sb-${team.id}-${idx}`;
                                      const isTbExp = expanded[tKey];
                                      return (
                                        <div key={tKey} className="rounded-xl border border-gray-200 bg-white overflow-hidden">
                                          <div
                                            onClick={() => toggle(tKey)}
                                            className="flex items-center justify-between px-3 py-2 bg-gray-50 cursor-pointer hover:bg-gray-100"
                                          >
                                            <div className="min-w-0">
                                              <h5 className="font-bold text-sm truncate">{tb.name}</h5>
                                              <p className="text-xs text-gray-600">
                                                Finish: #{tb.pos} • Players {tb.baseScore} • Bonus +{tb.cutBonus} ({tb.madeCutCount} in cut line)
                                              </p>
                                            </div>
                                            <div className="flex items-center gap-3">
                                              <div className="text-right">
                                                <div className="font-bold text-green-700 score-num">{tb.score}</div>
                                              </div>
                                              <div className="text-xs text-gray-500">{isTbExp ? '▼' : '▶'}</div>
                                            </div>
                                          </div>
                                          {isTbExp && (
                                            <div className="px-3 py-2">
                                              <div className="grid grid-cols-2 gap-2">
                                                {(tb.players || []).map((p, pidx) => (
                                                  <div key={pidx} className="text-xs">
                                                    <span className="font-semibold">{p.name}</span>
                                                    <span className="ml-1 text-gray-500">({p.pos})</span>
                                                    <span className="ml-1 font-bold text-green-700">{p.points}</span>
                                                  </div>
                                                ))}
                                              </div>
                                            </div>
                                          )}
                                        </div>
                                      );
                                    })}
                                  </div>
                                </div>
                              </div>
                            )}                          </div>
                        );
                      })}
                    </div>
                  </>
                )}
              </div>
            )}

            {tab === 'stats' && (
              <div className="glass rounded-2xl shadow-2xl p-4 sm:p-8">
                <div className="flex items-start justify-between flex-wrap gap-4 mb-6">
                  <div>
                    <h2 className="text-3xl font-bold text-gray-900">📈 Player Stats &amp; Analytics</h2>
                    <p className="text-sm text-gray-600 mt-1">
                      Golfer leaderboards based on season-long fantasy points (
                        {fantasySeason?.bounds?.start?.label || 'Season Start'}
                        {' → '}
                        {fantasySeason?.bounds?.end?.label || 'Season End'}
                      ).
                    </p>
                  </div>
                  
                </div>

                {!fantasySeason?.bounds ? (
                  <div className="text-center py-12">
                    <p className="text-xl text-gray-600">Loading season window…</p>
                  </div>
                ) : !fantasySeason?.started ? (
                  <div className="text-center py-12">
                    <p className="text-xl text-gray-800 font-bold">Fantasy season has not started yet</p>
                    <p className="text-sm text-gray-600 mt-2">
                      Stats begin after <strong>{fantasySeason.bounds.start.label}</strong> is complete
                      and run through <strong>{fantasySeason.bounds.end.label}</strong>.
                    </p>
                  </div>
                ) : history.length === 0 ? (
                  <div className="text-center py-12">
                    <p className="text-xl text-gray-600">No tournament data yet</p>
                  </div>
                ) : (
                  <>
                    <div className="glass rounded-xl p-2 mb-6">
                      <div className="grid grid-cols-1 gap-2 sm:grid-cols-3">
                        {[
                          ['points', '🏅 Points Leaders'],
                          ['value', '💎 Value Leaders'],
                          ['optimal', '🧩 Optimal Lineup'],
                        ].map(([k, l]) => (
                          <button
                            key={k}
                            onClick={() => setStatsSubtab(k)}
                            className={`flex-1 ${c('px-3 py-2 text-sm','px-4 py-3')} rounded-lg font-bold transition ${
                              statsSubtab === k
                                ? 'bg-gradient-to-r from-emerald-600 to-teal-600 text-white shadow'
                                : 'bg-white/70 text-gray-800 hover:bg-white'
                            }`}
                          >
                            {l}
                          </button>
                        ))}
                      </div>
                    </div>

                                        {statsSubtab === 'value' && (
                      <div className="mb-6">
                        <div className="flex items-center justify-between flex-wrap gap-3">
                          <div className="text-sm text-gray-700">
                            <span className="font-semibold">Adjusted Value</span> = <span className="font-semibold">points per dollar</span>, adjusted so players with more tournaments played are <span className="font-semibold">trusted more</span>{' '}
                            <span className="text-gray-500">(fixed league pricing)</span>
                          </div>
                          <button
                            onClick={() => toggle('bayes-help')}
                            className="text-xs font-bold px-3 py-1.5 rounded-lg border border-gray-200 bg-white/70 hover:bg-white text-gray-800"
                          >
                            {expanded['bayes-help'] ? 'Hide details ▲' : 'How is this calculated? ▼'}
                          </button>
                        </div>

                        <div className="mt-2 text-xs text-gray-600">
                          <span className="font-semibold">League Avg points/$</span>: <span className="score-num">{Number.isFinite(leagueAvgRoi) ? leagueAvgRoi.toFixed(2) : '—'}</span>
                          <span className="mx-2 text-gray-400">•</span>
                          <span className="font-semibold">Starts</span> = tournaments played
                          <span className="mx-2 text-gray-400">•</span>
                          <span className="font-semibold">Points</span> = season fantasy points (team cut bonus not included)
                        </div>

                        {expanded['bayes-help'] && (
                          <div className="mt-2 rounded-lg border border-gray-200 bg-gray-50/70 px-3 py-2 text-xs text-gray-700">
                            <div className="font-extrabold text-gray-900">Adjusted Value (easy explanation)</div>
                            <ul className="list-disc ml-5 mt-1 space-y-1">
                              <li>
                                <span className="font-semibold">Start with points per dollar</span>: Season Pts ÷ Price.
                              </li>
                              <li>
                                <span className="font-semibold">Assume “average” until proven</span>: we blend a golfer’s number with the{' '}
                                <span className="font-semibold">league-average points per dollar</span>.
                              </li>
                              <li>
                                <span className="font-semibold">More starts</span> → we trust the golfer’s own results more.{' '}
                                <span className="font-semibold">Fewer starts</span> → we lean more on the average.
                              </li>
                            </ul>

                            <div className="mt-2 text-gray-600">
                              <span className="font-semibold">Example:</span> Golfer is at <span className="score-num">10</span> points/$ after{' '}
                              <span className="score-num">1</span> start. League average is <span className="score-num">6</span> points/$. With K=
                              <span className="score-num">{BAYES_K}</span>, weight is 1/(1+{BAYES_K}) ≈ 0.33, so:
                              <span className="ml-1 font-semibold">Adjusted Value ≈ 0.33×10 + 0.67×6 = 7.33</span>.
                            </div>

                            <div className="mt-2 text-gray-500">
                              Math version (if you’re curious): <span className="font-semibold">w×(SeasonPts÷Price) + (1−w)×LeagueAvg</span>, where{' '}
                              <span className="font-semibold">w = Starts/(Starts + K)</span>.
                            </div>
                          </div>
                        )}
                      </div>
                    )}

{statsSubtab === 'optimal' ? (
  <div className="space-y-4">
    <div className="rounded-xl border border-gray-200 bg-white/80 px-4 py-3">
      <div className="flex items-start justify-between flex-wrap gap-4">
        <div>
          <div className="text-sm font-extrabold text-gray-900">
            Optimal 6-golfer lineup under <span className="score-num">{'$'}{optimalLineup.cap}</span>
          </div>
          <div className="text-xs text-gray-600 mt-1">
            Built by maximizing <span className="font-semibold">Season Points</span> under the salary cap. <span className="text-gray-500">(Ties broken by Adjusted Value.)</span>
            If there’s a tie, we pick the lineup with the higher total <span className="font-semibold">Adjusted Value</span>.
          </div>
        </div>
        <div className="text-right">
          <div className="text-sm text-gray-800 font-bold">
            Total Cost:{' '}
            <span className="score-num">{optimalLineup.best ? optimalLineup.best.totalCost : 0}</span> /{' '}
            <span className="score-num">{optimalLineup.cap}</span>
          </div>
          <div className="text-sm text-gray-800 font-bold">
            Season Pts:{' '}
            <span className="score-num text-emerald-700">{Math.round(optimalLineup.best ? optimalLineup.best.totalPoints : 0)}</span>
          </div>
          <div className="text-xs text-gray-600">
            Remaining:{' '}
            <span className="score-num">{optimalLineup.best ? optimalLineup.best.remaining : optimalLineup.cap}</span>
          </div>
        </div>
      </div>

      {optimalLineup.note && (
        <div className="mt-3 text-sm text-red-700 font-semibold">{optimalLineup.note}</div>
      )}
    </div>

    <div className="overflow-hidden rounded-xl border border-gray-200 bg-white">
      <div className="overflow-auto">
        <table className="w-full text-sm">
          <thead className="bg-gray-50 sticky top-0">
            <tr className="border-b">
              <th className="text-left py-2 px-3 font-extrabold text-gray-700">#</th>
              <th className="text-left py-2 px-3 font-extrabold text-gray-700">Golfer</th>
              <th className="text-right py-2 px-3 font-extrabold text-gray-700">Price</th>
              <th className="text-right py-2 px-3 font-extrabold text-gray-700">Season Pts</th>
              <th className="text-right py-2 px-3 font-extrabold text-gray-700">Starts</th>
              <th className="text-right py-2 px-3 font-extrabold text-gray-700">Adj Val</th>
            </tr>
          </thead>
          <tbody>
            {((optimalLineup.best && optimalLineup.best.players) || []).map((g, idx) => (
              <tr
                key={g.key}
                className="border-b last:border-b-0 hover:bg-emerald-50/40"
              >
                <td className="py-2 px-3 font-bold text-gray-900">{idx + 1}</td>
                <td className="py-2 px-3 font-semibold text-gray-900">{g.name}</td>
                <td className="py-2 px-3 text-right font-bold text-gray-900 score-num">
                  {Math.round(g.price)}
                </td>
                <td className="py-2 px-3 text-right font-bold text-emerald-700 score-num">
                  {Math.round(g.points)}
                </td>
                <td className="py-2 px-3 text-right text-gray-700 score-num">{g.starts}</td>
                <td className="py-2 px-3 text-right font-bold text-teal-700 score-num">
                  {Number.isFinite(g.bayesValue) ? g.bayesValue.toFixed(2) : '—'}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      
    {optimalLineup.best && (optimalLineup.alternatives || []).length > 0 && (
      <div className="overflow-hidden rounded-xl border border-gray-200 bg-white">
        <div className="px-4 py-3 bg-gray-50 border-b">
          <div className="text-sm font-extrabold text-gray-900">Next Best Lineups</div>
          <div className="text-xs text-gray-600 mt-0.5">
            A quick comparison set to show how far ahead the optimal lineup is (by Season Points).
          </div>
        </div>
        <div className="overflow-auto">
          <table className="w-full text-sm">
            <thead className="bg-white sticky top-0">
              <tr className="border-b">
                <th className="text-left py-2 px-3 font-extrabold text-gray-700">Rank</th>
                <th className="text-right py-2 px-3 font-extrabold text-gray-700">Season Pts</th>
                <th className="text-right py-2 px-3 font-extrabold text-gray-700">Δ vs Best</th>
                <th className="text-right py-2 px-3 font-extrabold text-gray-700">Cost</th>
                <th className="text-right py-2 px-3 font-extrabold text-gray-700">Remaining</th>
                <th className="text-left py-2 px-3 font-extrabold text-gray-700">Golfers</th>
              </tr>
            </thead>
            <tbody>
              {(optimalLineup.alternatives || []).map((lu, idx) => {
                const open = expanded[`o-${lu.key}`];
                return (
                  <React.Fragment key={lu.key}>
                    <tr
                      onClick={() => toggle(`o-${lu.key}`)}
                      className="border-b last:border-b-0 hover:bg-emerald-50/30 cursor-pointer"
                      title="Click to view golfer points"
                    >
                      <td className="py-2 px-3 font-bold text-gray-900">#{idx + 2}</td>
                      <td className="py-2 px-3 text-right font-bold text-emerald-700 score-num">
                        {Math.round(lu.totalPoints)}
                      </td>
                      <td className="py-2 px-3 text-right text-gray-700 score-num">
                        {Math.round((optimalLineup.best.totalPoints || 0) - (lu.totalPoints || 0))}
                      </td>
                      <td className="py-2 px-3 text-right font-bold text-gray-900 score-num">
                        {lu.totalCost}
                      </td>
                      <td className="py-2 px-3 text-right text-gray-700 score-num">{lu.remaining}</td>
                      <td className="py-2 px-3 text-xs text-gray-800">
                        {lu.players.map((p) => p.name).join(', ')}
                      </td>
                    </tr>

                    {open && (
                      <tr className="border-b last:border-b-0 bg-gray-50">
                        <td colSpan={6} className="py-3 px-3">
                          <div className="overflow-hidden rounded-lg border border-gray-200 bg-white">
                            <div className="px-3 py-2 bg-gray-50 border-b text-xs font-extrabold text-gray-700">
                              Golfer points for this lineup
                            </div>
                            <div className="overflow-auto">
                              <table className="w-full text-xs">
                                <thead className="bg-white sticky top-0">
                                  <tr className="border-b">
                                    <th className="text-left py-2 px-3 font-extrabold text-gray-700">Golfer</th>
                                    <th className="text-right py-2 px-3 font-extrabold text-gray-700">Price</th>
                                    <th className="text-right py-2 px-3 font-extrabold text-gray-700">Season Pts</th>
                                    <th className="text-right py-2 px-3 font-extrabold text-gray-700">Starts</th>
                                    <th className="text-right py-2 px-3 font-extrabold text-gray-700">Adj Val</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {lu.players.map((p) => (
                                    <tr key={p.key} className="border-b last:border-b-0">
                                      <td className="py-2 px-3 font-semibold text-gray-900">{p.name}</td>
                                      <td className="py-2 px-3 text-right font-bold text-gray-900 score-num">
                                        {Math.round(p.price)}
                                      </td>
                                      <td className="py-2 px-3 text-right font-bold text-emerald-700 score-num">
                                        {Math.round(p.points)}
                                      </td>
                                      <td className="py-2 px-3 text-right text-gray-700 score-num">{p.starts}</td>
                                      <td className="py-2 px-3 text-right font-bold text-teal-700 score-num">
                                        {Number.isFinite(p.bayesValue) ? p.bayesValue.toFixed(2) : '—'}
                                      </td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        </td>
                      </tr>
                    )}
                  </React.Fragment>
                );
              })}
            </tbody>
          </table>
        </div>
      </div>
    )}
</div>
    </div>
  </div>
) : (
                    <div className="overflow-hidden rounded-xl border border-gray-200 bg-white">
                      <div className="overflow-auto">
                        <table className="w-full text-sm">
                          <thead className="bg-gray-50 sticky top-0">
                            <tr className="border-b">
                              <th className="text-left py-2 px-3 font-extrabold text-gray-700">#</th>
                              <th className="text-left py-2 px-3 font-extrabold text-gray-700">Golfer</th>
                              {statsSubtab === 'value' && (
                                <th className="text-right py-2 px-3 font-extrabold text-gray-700">Price</th>
                              )}
                              <th className="text-right py-2 px-3 font-extrabold text-gray-700">'Season Pts'</th>
                              <th className="text-right py-2 px-3 font-extrabold text-gray-700">Events</th>
                              <th className="text-right py-2 px-3 font-extrabold text-gray-700">Avg</th>
                              {statsSubtab === 'value' && (
                                <th className="text-right py-2 px-3 font-extrabold text-gray-700">Adj Val</th>
                              )}
                            </tr>
                          </thead>
                          <tbody>
                            {(statsSubtab === 'value' ? golferValue : golferStats)
                              .filter(golferMatchesSearch)
                              .slice(0, 200)
                              .map((g, idx) => {
                                const expKey = `pg-${statsSubtab}-${g.key}`;
                                const isExp = !!expanded[expKey];
                                const colSpan = statsSubtab === 'value' ? 7 : 5;
                                const rows = Array.isArray(g.tournaments) ? g.tournaments : [];

                                return (
                                  <React.Fragment key={g.key}>
                                    <tr
                                      onClick={() => toggle(expKey)}
                                      className={`border-b last:border-b-0 hover:bg-emerald-50/40 cursor-pointer ${isExp ? 'bg-emerald-50/30' : ''}`}
                                    >
                                      <td className="py-2 px-3 font-bold text-gray-900">{idx + 1}</td>
                                      <td className="py-2 px-3 font-semibold text-gray-900">
                                        {g.name}
                                        <span className="ml-2 text-gray-400">{isExp ? '▼' : '▶'}</span>
                                      </td>
                                      {statsSubtab === 'value' && (
                                        <td className="py-2 px-3 text-right font-bold text-gray-900 score-num">
                                          {g.price ?? '—'}
                                        </td>
                                      )}
                                      <td className="py-2 px-3 text-right font-bold text-emerald-700 score-num">
                                        {Math.round(g.totalPoints)}
                                      </td>
                                      <td className="py-2 px-3 text-right text-gray-700 score-num">{g.events}</td>
                                      <td className="py-2 px-3 text-right text-gray-700 score-num">
                                        {Number.isFinite(g.avgPoints) ? g.avgPoints.toFixed(1) : '0.0'}
                                      </td>
                                      {statsSubtab === 'value' && (
                                        <td className="py-2 px-3 text-right font-bold text-teal-700 score-num">
                                          {g.bayesValue != null ? g.bayesValue.toFixed(2) : '—'}
                                        </td>
                                      )}
                                    </tr>

                                    {isExp && (
                                      <tr className="border-b last:border-b-0 bg-gray-50/70">
                                        <td colSpan={colSpan} className="py-2 px-3">
                                          <div className="rounded-lg border border-gray-200 bg-white/70 p-3">
                                            <div className="flex items-center justify-between mb-2">
                                              <div className="text-xs font-extrabold text-gray-800">Tournament breakdown</div>
                                              <div className="text-xs text-gray-500">
                                                {rows.length} event{rows.length === 1 ? '' : 's'}
                                              </div>
                                            </div>
                                            {rows.length === 0 ? (
                                              <div className="text-xs text-gray-600">No tournament results found.</div>
                                            ) : (
                                              <div className="overflow-x-auto">
                                                <table className="w-full text-xs">
                                                  <thead>
                                                    <tr className="border-b border-gray-200">
                                                      <th className="text-left py-1 px-2 font-bold text-gray-600">Tournament</th>
                                                      <th className="text-center py-1 px-2 font-bold text-gray-600">Pos</th>
                                                      <th className="text-center py-1 px-2 font-bold text-gray-600">Score</th>
                                                      <th className="text-right py-1 px-2 font-bold text-gray-600">Points</th>
                                                    </tr>
                                                  </thead>
                                                  <tbody>
                                                    {rows.map((tb, tbi) => (
                                                      <tr key={(tb.eventId || '') + tbi} className="border-b last:border-b-0">
                                                        <td className="py-1 px-2 font-semibold text-gray-800">{tb.name}</td>
                                                        <td className="text-center py-1 px-2 text-gray-700">{tb.pos}</td>
                                                        <td className="text-center py-1 px-2 text-gray-700">{tb.score}</td>
                                                        <td className="text-right py-1 px-2 font-bold text-emerald-700 score-num">
                                                          {Math.round(tb.points || 0)}
                                                        </td>
                                                      </tr>
                                                    ))}
                                                  </tbody>
                                                </table>
                                              </div>
                                            )}
                                          </div>
                                        </td>
                                      </tr>
                                    )}
                                  </React.Fragment>
                                );
                              })}
                          </tbody>
                        </table>
                      </div>
                    </div>
                    )}

                    {history.some((t) => !Array.isArray(t.field)) && (
                      <p className="text-sm text-gray-500 mt-4">
                        Note: older tournaments saved before analytics were added may not include full-field
                        data, so some golfers may be missing until those events are re-synced.
                      </p>
                    )}
                  </>
                )}
              </div>
            )}

          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  
    </script>
</body>
</html>
